<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Conda搭建python环境</title>
      <link href="/2022/01/15/a_id_27/"/>
      <url>/2022/01/15/a_id_27/</url>
      
        <content type="html"><![CDATA[<h1 id="Conda使用指南"><a href="#Conda使用指南" class="headerlink" title="Conda使用指南"></a>Conda使用指南</h1><p>我们在使用python语言的时候，有时可能会为了环境问题而烦恼，并且python的版本也是很多，相关库的依赖性很强，在库的安装和版本的管理会有很大的麻烦，Conda说白了就是一个管理版本和python环境的一套工具，使用起来非常的方便</p><p>首先你也得先进入<a href>conda</a>官网，选择对应的版本进行下载安装</p><h2 id="下载之后说一下Conda的环境管理"><a href="#下载之后说一下Conda的环境管理" class="headerlink" title="下载之后说一下Conda的环境管理"></a>下载之后说一下Conda的环境管理</h2><h3 id="创建环境"><a href="#创建环境" class="headerlink" title="创建环境"></a>创建环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 第一种指定版本 创建一个名称为 python_3.8环境， 指定版本也是python3.8版本</span><br><span class="line">conda create --name pyhon_3.8 python&#x3D;3.8</span><br><span class="line"># 第二种指定配置文件环境  environment.yml（配置文件）</span><br><span class="line">conda env create -f environment.yml</span><br></pre></td></tr></table></figure><h3 id="查看环境"><a href="#查看环境" class="headerlink" title="查看环境"></a>查看环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有环境</span><br><span class="line">conda info --env 或者 conda env list</span><br></pre></td></tr></table></figure><h3 id="切换环境"><a href="#切换环境" class="headerlink" title="切换环境"></a>切换环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 切换环境</span><br><span class="line">conda activate 环境名</span><br></pre></td></tr></table></figure><h3 id="删除环境"><a href="#删除环境" class="headerlink" title="删除环境"></a>删除环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 删除指定环境</span><br><span class="line">conda remove -n 虚拟环境名称</span><br></pre></td></tr></table></figure><h3 id="解决在指定环境中-pip-install下载速度慢问题"><a href="#解决在指定环境中-pip-install下载速度慢问题" class="headerlink" title="解决在指定环境中 pip install下载速度慢问题"></a>解决在指定环境中 pip install下载速度慢问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#显示目前conda的数据源有哪些</span><br><span class="line">conda config --show channels</span><br><span class="line">#添加数据源：例如, 添加清华anaconda镜像：</span><br><span class="line">conda config --add channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;free&#x2F;</span><br><span class="line">conda config --add channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;main&#x2F;</span><br><span class="line">conda config --set show_channel_urls yes</span><br><span class="line">#删除数据源</span><br><span class="line">conda config --remove channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;free&#x2F;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alipay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Python模仿PC端微信恢复</title>
      <link href="/2021/10/22/a_id_26/"/>
      <url>/2021/10/22/a_id_26/</url>
      
        <content type="html"><![CDATA[<p style="font-size:17px">本篇呢主要是利用这个python的两个依赖库(PyAutoGUI和pyperclip)来进行微信自动恢复消息</p><br><p style="font-size:21px">介绍下这两个依赖库</p><p style="font-size:17px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PyAutoGUI是一个纯Python的GUI自动化工具，其目的是可以用程序自动控制鼠标和键盘操作，利用它可以实现自动化任务，再也不用担心有重复枯燥的任务了。</p><p style="font-size:17px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PyPeRCLIP模块中有两个函数，分别是copy ()和paste ()，copy ()用于向计算机的剪贴板发送文本，paste ()用于从计算机剪贴板接收文本</p><h4 id="介绍完后直接安装下依赖库"><a href="#介绍完后直接安装下依赖库" class="headerlink" title="介绍完后直接安装下依赖库"></a>介绍完后直接安装下依赖库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install pyautogui -i http:&#x2F;&#x2F;pypi.douban.com&#x2F;simple&#x2F; --trusted-host pypi.douban.com</span><br><span class="line">pip3 install pyperclip -i http:&#x2F;&#x2F;pypi.douban.com&#x2F;simple&#x2F; --trusted-host pypi.douban.com</span><br></pre></td></tr></table></figure><h4 id="安装后进入代码"><a href="#安装后进入代码" class="headerlink" title="安装后进入代码"></a>安装后进入代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"># 导入依赖及需要的包</span><br><span class="line">import pyautogui  </span><br><span class="line">import pyperclip</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def get_msg():</span><br><span class="line">   &quot;&quot;&quot;想发的消息，每条消息空格分开&quot;&quot;&quot;</span><br><span class="line">   contents &#x3D; &quot;您好&quot;</span><br><span class="line">   return contents.split(&quot; &quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def send(msg):</span><br><span class="line">    # 复制需要发送的内容到粘贴板</span><br><span class="line">    pyperclip.copy(msg)</span><br><span class="line">    # 模拟键盘 ctrl + v 粘贴内容</span><br><span class="line">    pyautogui.hotkey(&#39;ctrl&#39;, &#39;v&#39;)</span><br><span class="line">    # 发送消息</span><br><span class="line">    pyautogui.press(&#39;enter&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def send_msg(friend):</span><br><span class="line">    # Ctrl + alt + w  模仿控制快捷键</span><br><span class="line">    pyautogui.hotkey(&#39;ctrl&#39;, &#39;alt&#39;, &#39;w&#39;)</span><br><span class="line">    # 搜索好友</span><br><span class="line">    pyautogui.hotkey(&#39;ctrl&#39;, &#39;f&#39;)</span><br><span class="line">    # 复制好友昵称到粘贴板</span><br><span class="line">    pyperclip.copy(friend)</span><br><span class="line">    # 模拟键盘 ctrl + v 粘贴</span><br><span class="line">    pyautogui.hotkey(&#39;ctrl&#39;, &#39;v&#39;)</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    # 回车进入好友消息界面</span><br><span class="line">    pyautogui.press(&#39;enter&#39;)</span><br><span class="line">    # 一条一条发送消息</span><br><span class="line">    for msg in get_msg():</span><br><span class="line"></span><br><span class="line">        send(msg)</span><br><span class="line">        # 每条消息间隔 2 秒</span><br><span class="line">        time.sleep(2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    friend_name &#x3D; &quot;黄总&quot;</span><br><span class="line">    send_msg(friend_name)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alipay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双系统Mongo备份与恢复问题(压缩包格式)</title>
      <link href="/2021/10/13/a_id_25/"/>
      <url>/2021/10/13/a_id_25/</url>
      
        <content type="html"><![CDATA[<h3 id="一、关于Mongo的mongodump的备份"><a href="#一、关于Mongo的mongodump的备份" class="headerlink" title="一、关于Mongo的mongodump的备份"></a>一、关于Mongo的mongodump的备份</h3><br><p style="font-size:17px">首先介绍下一些参数问题</p><p style="font-size:17px">-h： MongDB所在服务器地址，例如：127.0.0.1，当然也可以指定端口号：127.0.0.1:27017</p><p style="font-size:17px">-d： </p><p style="font-size:17px">需要备份的数据库实例，例如：test</p><p style="font-size:17px">-o： 备份的数据存放位置，例如：d:\data\dump，当然该目录需要提前建立，在备份完成后，系统自动在dump目录下建立一个test目录，这个目录里面存放该数据库实例的备份数据。</p><p style="font-size:17px">--archive： 打包好的文件保存地址<br><br></p><p style="font-size:23px">使用mongodump命令来进行打包</p><p style="font-size:17px">mongodump -h 127.0.0.1 --port 27017 -d work -c worek --authenticationDatabase=admin  --gzip --archive=C:\Users\desktop\es.tar.gz出现这个代表备份成功啦, 2条数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">021-10-18T17:40:16.548+0800    writing work.work to archive &#39;C:\Users\desktop\es.tar.gz&#39;</span><br><span class="line">2021-10-18T17:40:16.570+0800    done dumping work.work (2 documents)</span><br></pre></td></tr></table></figure><br></p><h3 id="二、恢复mongorestore"><a href="#二、恢复mongorestore" class="headerlink" title="二、恢复mongorestore"></a>二、恢复mongorestore</h3><p style="font-size:17px">当然有备份, 就有恢复, 恢复数据的话可以分成2种方式, 第一种原表恢复, 另一种就是重命名空间恢复<ul><li><p style="font-size:17px">第一种</p></li></ul></p><p style="font-size:17px">首先来说一下原表恢复, 也就是说我刚才从work数据库中的work表中备份的,测试的时候可以把原来表中数据删除,方便看效果.</p><p style="font-size:17px">--nsInclude 这个参数表示你备份时原来的库名.表名 (例如work.work)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongorestore -h 127.0.0.1 --port&#x3D;27017 --nsInclude&#x3D;work.work --gzip --archive&#x3D;C:\Users\desktop\es.tar.gz</span><br></pre></td></tr></table></figure></p><p style="font-size:17px">出现这种就是数据已经恢复了, 这个时候可以去库查看一下, 已经恢复好了, 也是成功恢复了2条数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2021-10-18T17:50:42.409+0800    preparing collections to restore from</span><br><span class="line">2021-10-18T17:50:42.437+0800    reading metadata for work.work from archive &#39;C:\Users\desktop\es.tar.gz&#39;</span><br><span class="line">2021-10-18T17:50:42.438+0800    restoring work.work from archive &#39;C:\Users\desktop\es.tar.gz&#39;</span><br><span class="line">2021-10-18T17:50:42.439+0800    error: multiple errors in bulk operation:</span><br><span class="line">  - E11000 duplicate key error collection: work.work index: _id_ dup key: &#123; : ObjectId(&#39;60514fd1703c9b2e2964738b&#39;) &#125;</span><br><span class="line">  - E11000 duplicate key error collection: work.work index: _id_ dup key: &#123; : ObjectId(&#39;605151b8703c9b2e2964738c&#39;) &#125;</span><br><span class="line"></span><br><span class="line">2021-10-18T17:50:42.439+0800    no indexes to restore</span><br><span class="line">2021-10-18T17:50:42.440+0800    finished restoring work.work (2 documents)</span><br><span class="line">2021-10-18T17:50:42.441+0800    done</span><br></pre></td></tr></table></figure><br><ul><li><p style="font-size:17px">第二种</p></li></ul></p><p style="font-size:17px">来说一下重新命名方法</p><p style="font-size:17px">我们这次将恢复到work数据库下的work2表中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongorestore -h 127.0.0.1 --port&#x3D;27017  --nsFrom work.work  --nsTo work.work2 --gzip --archive&#x3D;C:\Users\Desktop\es.tar.gz </span><br></pre></td></tr></table></figure></p><p style="font-size:17px">大功告成<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2021-10-18T17:56:35.257+0800    preparing collections to restore from</span><br><span class="line">2021-10-18T17:56:35.283+0800    reading metadata for work.work2 from archive &#39;C:\Users\Desktop\es.tar.gz&#39;</span><br><span class="line">2021-10-18T17:56:35.290+0800    restoring work.work2 from archive &#39;C:\Users\Desktop\es.tar.gz&#39;</span><br><span class="line">2021-10-18T17:56:35.291+0800    no indexes to restore</span><br><span class="line">2021-10-18T17:56:35.291+0800    finished restoring work.work2 (2 documents)</span><br><span class="line">2021-10-18T17:56:35.296+0800    done</span><br></pre></td></tr></table></figure><br></p><p style="font-size:17px">注意的是 --nsFrom work.work --nsTo work.work2 --nsFrom 这个是你原来的备份的位置, --nsTo这个是你要重新命名的位置</p><p style="font-size:17px">更多参数可查看官方文档</p><p><a href="https://www.mongodb.com/zh-cn">https://www.mongodb.com/zh-cn</a></p>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alipay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下设置容器中Redis密码</title>
      <link href="/2021/09/29/a_id_24/"/>
      <url>/2021/09/29/a_id_24/</url>
      
        <content type="html"><![CDATA[<h3 id="1-首先拉取Redis镜像过来"><a href="#1-首先拉取Redis镜像过来" class="headerlink" title="1.首先拉取Redis镜像过来"></a>1.首先拉取Redis镜像过来</h3><p>这里可以去指定版本进行拉取不同的版本 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis </span><br></pre></td></tr></table></figure><h3 id="2-这里可以查看一下镜像"><a href="#2-这里可以查看一下镜像" class="headerlink" title="2.这里可以查看一下镜像"></a>2.这里可以查看一下镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><h3 id="3-确定镜像存在后通过镜像启动容器"><a href="#3-确定镜像存在后通过镜像启动容器" class="headerlink" title="3.确定镜像存在后通过镜像启动容器"></a>3.确定镜像存在后通过镜像启动容器</h3><p>设置密码只需要加–requirepass “yourpassword”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 6379:6379 --name redis --requirepass &quot;yourpassword&quot;</span><br></pre></td></tr></table></figure><h3 id="4-然后可以进入容器进行验证"><a href="#4-然后可以进入容器进行验证" class="headerlink" title="4.然后可以进入容器进行验证"></a>4.然后可以进入容器进行验证</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 容器名或id &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>redis-cli 进入</p><p>注意 只有在你输入命令时才会触发密码</p><p>127.0.0.1:6379&gt; get *<br>(error) NOAUTH Authentication required.</p><h3 id="5-进行验证密码"><a href="#5-进行验证密码" class="headerlink" title="5.进行验证密码"></a>5.进行验证密码</h3><p>输入完显示OK就表示验证成功啦</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth password</span><br></pre></td></tr></table></figure><p>127.0.0.1:6379&gt; auth [设置的密码]<br>OK</p><h3 id="这样的话就大功告成啦"><a href="#这样的话就大功告成啦" class="headerlink" title="这样的话就大功告成啦"></a>这样的话就大功告成啦</h3>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alipay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于ApiDoc快速制作文档</title>
      <link href="/2021/09/27/a_id_23/"/>
      <url>/2021/09/27/a_id_23/</url>
      
        <content type="html"><![CDATA[<h1 id="ApiDoc文档自动化生成工具"><a href="#ApiDoc文档自动化生成工具" class="headerlink" title="ApiDoc文档自动化生成工具"></a>ApiDoc文档自动化生成工具</h1><h2 id="首先来介绍下ApiDoc文档自动化生成工具-apidoc是一个轻量级的在线REST接口文档生成系统，支持多种主流语言，包括Java、C、C-、PHP和Javascript等都是支持的。"><a href="#首先来介绍下ApiDoc文档自动化生成工具-apidoc是一个轻量级的在线REST接口文档生成系统，支持多种主流语言，包括Java、C、C-、PHP和Javascript等都是支持的。" class="headerlink" title="首先来介绍下ApiDoc文档自动化生成工具,apidoc是一个轻量级的在线REST接口文档生成系统，支持多种主流语言，包括Java、C、C#、PHP和Javascript等都是支持的。"></a>首先来介绍下ApiDoc文档自动化生成工具,apidoc是一个轻量级的在线REST接口文档生成系统，支持多种主流语言，包括Java、C、C#、PHP和Javascript等都是支持的。</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><p style="font-size:17px">    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apidoc是基于nodeJs平台，在安装apidoc之前，需要先安装nodeJs。关于nodeJs的安装，一搜一大把，不过为了文章的完整性，还是首先介绍一下Windows平台下nodeJs的安装。</p><br><ul><li>进入windows的cmd 输入以下命令安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install apidoc -g</span><br></pre></td></tr></table></figure><h3 id="2-操作"><a href="#2-操作" class="headerlink" title="2.操作"></a>2.操作</h3></li><li>在使用之前需要生成接口文档的目录下新建一个apidoc.json<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;   </span><br><span class="line">  &quot;name&quot;: &quot;example&quot;,   # 文档名字</span><br><span class="line">  &quot;version&quot;: &quot;0.1.0&quot;,  # 版本号</span><br><span class="line">  &quot;description&quot;: &quot;example&quot;,  # 详细介绍  </span><br><span class="line">  &quot;title&quot;: &quot;title&quot;,   # 文档标题</span><br><span class="line">  &quot;url&quot; : &quot;http:&#x2F;&#x2F;www.test.com&quot;  # api url的前缀</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>新建一个python文件：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @api &#123;post&#125; &#x2F;user 中文</span><br><span class="line"> * @apiName obj</span><br><span class="line"> * @apiParam &#123;Object&#125; person </span><br><span class="line"> * @apiParam &#123;String&#125; person.name  姓名 </span><br><span class="line"> * @apiParam &#123;Integer&#125; person.age 年龄 </span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure></li><li>直接使用apidoc命令生成文档<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apidoc</span><br></pre></td></tr></table></figure></li><li>apidoc参数说明：</li></ul><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-i</td><td align="center">选择源代码所在位置</td></tr><tr><td align="center">-o</td><td align="center">选择目标生成所在的位置</td></tr></tbody></table><p>更多参数可参考官方文档    <a href="https://apidocjs.com/">https://apidocjs.com/</a></p><ul><li>常用的一些命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apidoc -c path&#x2F;to&#x2F;apidoc.json</span><br></pre></td></tr></table></figure></li><li>以下就是生成后的模板</li></ul><p><img src="/.top//09/27/a_id_23/wc.png"></p>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alipay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于FastApi全局校验Token</title>
      <link href="/2021/09/02/a_id_22/"/>
      <url>/2021/09/02/a_id_22/</url>
      
        <content type="html"><![CDATA[<h1 id="Token介绍"><a href="#Token介绍" class="headerlink" title="Token介绍"></a>Token介绍</h1>  <p style="font-size:23px">  为什么使用Token验证：</p><p>  在Web领域基于Token的身份验证随处可见。在大多数使用Web API的互联网公司中，tokens 是多用户下处理认证的最佳方式。</p><p>  以下几点特性会让你在程序中使用基于Token的身份验证</p><p>  1.无状态、可扩展</p><p>  2.支持移动设备</p><p>  3.跨程序调用</p><p>  4.安全</p><p>  那些使用基于Token的身份验证的大佬们</p><p>  大部分你见到过的API和Web应用都使用tokens。例如Facebook, Twitter, Google+, GitHub等。</p><p></p>其实关于FastAPI添加校验很简单,只需要添加一个中间件即可, 如下:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@app.middleware(&quot;http&quot;)</span><br><span class="line">async def add_process_time_header(request: Request, call_next):</span><br><span class="line">  response &#x3D; await call_next(request)</span><br><span class="line"></span><br><span class="line">  login_url &#x3D; str(request.url)[22:]</span><br><span class="line">  register_url &#x3D; str(request.url)[22:]</span><br><span class="line"></span><br><span class="line">  if login_url &#x3D;&#x3D; &#39;login_user&#39; or register_url &#x3D;&#x3D; &#39;register_user&#39;:  # 屏蔽注册、登录接口, 避免死循环</span><br><span class="line">      return response</span><br><span class="line"></span><br><span class="line">  try:</span><br><span class="line">      token &#x3D; request.headers[&#39;token&#39;]  # 获取前端传过来token</span><br><span class="line">      # jwt.decode(token, key&#x3D;SECRET_KEY)</span><br><span class="line"></span><br><span class="line">  except Exception as e:</span><br><span class="line">      logger.warning(e)</span><br><span class="line">      return JSONResponse(&#123;&#39;msg&#39;: &#39;token验证失败,请重新登陆!&#39;, &#39;code&#39;: 301&#125;)</span><br><span class="line"></span><br><span class="line">  return response</span><br></pre></td></tr></table></figure>### 注意问题    在你添加中间件的时候,要想到它是一个全局的校验,也就是说,当你登录接口和注册接口来访问时如何应对,这个时候你可以把登录&注册接口屏蔽掉,避免死循环.    FastAPI启动方式: uvicorn.run(app='main:app', host="127.0.0.1", port=8008, reload=True, debug=True)]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alipay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Home Brew常用命令总结</title>
      <link href="/2021/06/05/a_id_21/"/>
      <url>/2021/06/05/a_id_21/</url>
      
        <content type="html"><![CDATA[<br><h1 id="Homebrew是什么？"><a href="#Homebrew是什么？" class="headerlink" title="Homebrew是什么？"></a>Homebrew是什么？</h1><p style="font-size:23px">    然后运行镜像脚本：    Homebrew是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2>   <p style="font-size:23p">     安装XCode或者Command Line Tools for Xcode。Xcode可以从AppStore里下载安装，Command Line Tools for Xcode需要在终端中输入以下代码运行安装：   </p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>   <p style="font-size:23p">     安装Homebrew。将以下命令粘贴至终端   </p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install)&quot;</span><br></pre></td></tr></table></figure><blockquote><p>安装完成以后，需要运行<code>brew doctor</code>命令检测下是否有什么冲突的地方（如没有卸载<code>MacPorts</code>等等）</p><p><code>Homebrew</code>安装成功后，会自动创建目录<code>/usr/local/Cellar</code>来存放<code>Homebrew</code>安装的程序。</p></blockquote>   <p style="font-size:23p">     安装Homebrew。将以下命令粘贴至终端   </p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;uninstall)&quot;</span><br></pre></td></tr></table></figure><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 搜索包</span></span><br><span class="line">brew search mysql</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安装包</span></span><br><span class="line">brew install mysql</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看包信息，比如目前的版本，依赖，安装后注意事项等</span></span><br><span class="line">brew info mysql</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载包</span></span><br><span class="line">brew uninstall wget</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示已安装的包</span></span><br><span class="line">brew <span class="built_in">list</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看brew的帮助</span></span><br><span class="line">brew –help</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新， 这会更新 Homebrew 自己</span></span><br><span class="line">brew update</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查过时（是否有新版本），这会列出所有安装的包里，哪些可以升级</span></span><br><span class="line">brew outdated</span><br><span class="line">brew outdated mysql</span><br><span class="line"></span><br><span class="line"><span class="comment">// 升级所有可以升级的软件们</span></span><br><span class="line">brew upgrade</span><br><span class="line">brew upgrade mysql</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理不需要的版本极其安装包缓存</span></span><br><span class="line">brew cleanup</span><br><span class="line">brew cleanup mysql</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre><code>安装软件：brew install 软件名，例：brew install wget</code></pre><p>　　搜索软件：brew search 软件名，例：brew search wget<br>　　卸载软件：brew uninstall 软件名，例：brew uninstall wget<br>　　更新所有软件：brew update<br>　　更新具体软件：brew upgrade 软件名 ，例：brew upgrade git<br>　　显示已安装软件：brew list<br>　　查看软件信息：brew info／home 软件名 ，例：brew info git ／ brew home git<br>　　显示包依赖：brew reps<br>　　显示安装的服务：brew services list<br>　　安装服务启动、停止、重启：brew services start/stop/restart serverName</p>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alipay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Alpine作为你Docker的Python开发基础镜像？其实Ubuntu更好一点</title>
      <link href="/2021/05/20/a_id_20/"/>
      <url>/2021/05/20/a_id_20/</url>
      
        <content type="html"><![CDATA[<p style="font-size:23px">当你想为你的Python开发环境选择一个基础镜像时，大多数人都会选择Alpine，为什么？因为它太小了，仅仅只有 5 MB 左右（对比 Ubuntu 系列镜像接近 100 MB），但事实的真相是，我们选择基础镜像并不是为了体验一下Python语法而已，在此基础上，我们需要调试和安装各种扩展，可能会安装很多三方依赖，甚至预设更多服务，在这种环境下，Alpine就并非是一个很好的选择了，本次我们就来分别在Alpine和Ubuntu上来体验一下</p><br><p style="font-size:23px">首先分别拉取Alpine和Ubuntu的镜像：</p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu:18.04</span><br><span class="line">docker pull alpine</span><br></pre></td></tr></table></figure><p style="font-size:23px">拉取完毕后，可以看到，体积上确实差距明显：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY                  TAG                   IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu                      18.04                 6526a1858e5d        2 weeks ago         64.2MB</span><br><span class="line">alpine                      latest                a24bb4013296        3 months ago        5.57MB</span><br></pre></td></tr></table></figure><p style="font-size:23px">ubuntu占用64mb，而alpine仅仅5.57mb。<pre><code>但是先别着急，假设我们的python应用需要做一些科学计算，并且将数据以图形的方式展示出来，这时候就需要matplotlib和pandas这两个库的帮助了，先用ubuntu来安装这俩个库，编写Dockerfile.ubuntu</code></pre></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.7-slim</span><br><span class="line">RUN pip install --no-cache-dir matplotlib pandas</span><br></pre></td></tr></table></figure><p style="font-size:23px"> 然后运行镜像脚本：</p><pre><code>docker build -f Dockerfile.ubuntu -t &#39;ubuntu-mat&#39; .</code></pre><p style="font-size:23px"> 可以看到，编译好的镜像从原先的60mb暴涨到了263mb。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">liuyue:blog liuyue$ docker images</span><br><span class="line">REPOSITORY                  TAG                   IMAGE ID            CREATED              SIZE</span><br><span class="line">ubuntu-mat                  latest                401f0425ce63        About a minute ago   263MB</span><br></pre></td></tr></table></figure><p style="font-size:23px"> 使用起来没有什么问题。<pre><code>现在，我们来试试Alpine，看看速度和体积上有没有比Ubuntu更具优势编写Dockerfile.alpine:</code></pre></p><pre><code>FROM python:3.7-alpineRUN pip install --no-cache-dir matplotlib pandas</code></pre><p style="font-size:23px"> 编译镜像脚本</p><pre><code>docker build -f Dockerfile.alpine -t &#39;alpine-mat&#39; .</code></pre><p style="font-size:23px">     在编译过程中，我们会发现报错了：</p><pre><code>liuyue:blog liuyue$ docker build -f Dockerfile.alpine -t &#39;alpine-mat&#39; .Sending build context to Docker daemon  112.1kBStep 1/2 : FROM python:3.7-alpine3.7-alpine: Pulling from library/pythondf20fa9351a1: Pull complete 36b3adc4ff6f: Pull complete 4db9de03f499: Pull complete cd38a04a61f4: Pull complete 6bbb0c43b470: Pull complete Digest: sha256:d1375bf0b889822c603622dc137b24fb7064e6c1863de8cc4262b61901ce4390Status: Downloaded newer image for python:3.7-alpine---&gt; 078114edb6beStep 2/2 : RUN pip install --no-cache-dir matplotlib pandas---&gt; Running in 6d3c44420e5cCollecting matplotlibDownloading matplotlib-3.3.1.tar.gz (38.8 MB)    ERROR: Command errored out with exit status 1:    command: /usr/local/bin/python -c &#39;import sys, setuptools, tokenize; sys.argv[0] = &#39;&quot;&#39;&quot;&#39;/tmp/pip-install-40p0g06u/matplotlib/setup.py&#39;&quot;&#39;&quot;&#39;; __file__=&#39;&quot;&#39;&quot;&#39;/tmp/pip-install-40p0g06u/matplotlib/setup.py&#39;&quot;&#39;&quot;&#39;;f=getattr(tokenize, &#39;&quot;&#39;&quot;&#39;open&#39;&quot;&#39;&quot;&#39;, open)(__file__);code=f.read().replace(&#39;&quot;&#39;&quot;&#39;\r\n&#39;&quot;&#39;&quot;&#39;, &#39;&quot;&#39;&quot;&#39;\n&#39;&quot;&#39;&quot;&#39;);f.close();exec(compile(code, __file__, &#39;&quot;&#39;&quot;&#39;exec&#39;&quot;&#39;&quot;&#39;))&#39; egg_info --egg-base /tmp/pip-pip-egg-info-zk64hzam        cwd: /tmp/pip-install-40p0g06u/matplotlib/</code></pre><br><p style="font-size:23px">     这是怎么搞的？如果你仔细看上面基于Ubuntu的构建，你会发现它下载三方库的安装包是matplotlib-3.1.2-cp38-cp38-manylinux1_x86_64.whl，这是一个预编译的二进制安装包。而Alpine则只能下载源代码（matplotlib-3.1.2.tar.gz）的压缩包，这就是Alpine的致命问题：标准的Linux安装包在Alpine Linux上根本无法使用。<pre><code>大多数Linux发行版都使用GNU版本的标准C库（glibc），几乎所有基于C语言的脚本语言都需要这个库，包括Python。但Alpine Linux使用的是musl，那些二进制安装包是针对glibc编译的，因此Alpine禁用了Linux安装包支持。现在大多数Python包都在PyPI上包含了二进制安装包，大大加快了安装时间。但是如果你使用的是Alpine Linux，你需要编译你使用的每一个Python包中的所有C源码。这也就意味着你需要自己弄清楚每一个系统库的依赖性。事先编译好需要的依赖，重新改写Dockerfile.alpine:</code></pre></p><pre><code>FROM python:3.7-alpineRUN apk --update add gcc build-base freetype-dev libpng-dev openblas-devRUN pip install --no-cache-dir matplotlib pandas</code></pre><br>    <p style="font-size:23px">     再次编译：    </p><pre><code>docker build -f Dockerfile.alpine -t &#39;alpine-mat&#39; .REPOSITORY                  TAG                   IMAGE ID            CREATED              SIZEalpine-mat                  latest                601f0425ce63        About a minute ago   873MB</code></pre><p style="font-size:23px">     可以看到体积已经变成873mb了，Alpine最引以为傲的体积小轻便等特性也已经荡然无存。<pre><code>虽然从理论上讲，Alpine使用的musl 内核与其他Linux发行版使用的glibc大多是兼容的，但在实际操作中，这种差异可能会造成各种问题。而当这些问题真的发生时，想解决它们就没那么简单了，比如说Alpine的线程默认堆栈容量较小，这会导致Python崩溃，同时也会影响python应用的运行速度。</code></pre></p>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alipay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雪花算法</title>
      <link href="/2021/03/27/a_id_19/"/>
      <url>/2021/03/27/a_id_19/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式系统-SnowFlake-雪花-算法"><a href="#分布式系统-SnowFlake-雪花-算法" class="headerlink" title="分布式系统 SnowFlake(雪花)算法"></a>分布式系统 SnowFlake(雪花)算法</h1><h3 id="引入"><a href="#引入" class="headerlink" title="引入~"></a>引入~</h3><blockquote><p>​        说起用户表以及订单表就必须使用唯一标识，而说起唯一标识大家应该多数都是使用的UUID吧，但是当数据量庞大时，一张表无法承载，就会分出N个表，我们都知道mysql的主键是自增长的、唯一、ID是整型（int），使得查询速度非常快，但是出现分布式系统的话就无法使用mysql自增长ID啦，这个时候就可以使用雪花算法实现唯一标识 ！</p></blockquote><p>为啥它叫雪花算法？ 这是因为我们大家都知道，雪是一团冰晶，在大气中形成，天下不可能有一模一样的雪花，尽管非常的相似，必然它们的形状也是有略不同 </p><p>​    </p><p>首先安装库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install pysnowflake</span><br></pre></td></tr></table></figure><p>安装完成后启动snowflake服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">snowflake_start_server --worker&#x3D;1</span><br></pre></td></tr></table></figure><p>worker指的是节点参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import snowflake.client</span><br><span class="line"></span><br><span class="line">print(snowflake.client.get_guid())</span><br><span class="line">4478873963216244737</span><br></pre></td></tr></table></figure><p>这里看到生成通过二进制转换成19位的十进制数字（id）</p><p>​    这里把它转换成二进制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> bin(4478873963216244737)</span><br><span class="line">&#39;0b11111000101000001010000010001110110011010000000001000000000001&#39;</span><br></pre></td></tr></table></figure><p>然后看到上面所述的是 第一位标识符，后面41位的时间戳，随后10位节点标识码，最后面12位000000000001，在向左数五位这就是存储的唯一标识，转换成10进制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(int(&#39;00001&#39;,2))</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>​        转换结果显示id存储在节点1的数据库中，使用反推逻辑定位到数据存储位置进行查询</p><p>​    </p><p>​        总结：</p><p>​            关于分布式id解决方案就是这样，其实不仅仅只有uuid和snowflake，像其它一些数据库也有独特的分布式        设计方案，使用的话就根据实际应用场景进行使用！</p>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alipay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于分页SQL优化问题</title>
      <link href="/2021/03/04/a_id_18/"/>
      <url>/2021/03/04/a_id_18/</url>
      
        <content type="html"><![CDATA[<h1 id="当我们在项目中的订单或者是用户到达海量数据时，无疑是要进行分页的，今天实现下sql查询海量数据时的优化功能。"><a href="#当我们在项目中的订单或者是用户到达海量数据时，无疑是要进行分页的，今天实现下sql查询海量数据时的优化功能。" class="headerlink" title="当我们在项目中的订单或者是用户到达海量数据时，无疑是要进行分页的，今天实现下sql查询海量数据时的优化功能。"></a>当我们在项目中的订单或者是用户到达海量数据时，无疑是要进行分页的，今天实现下sql查询海量数据时的优化功能。</h1><h2 id="实现分页"><a href="#实现分页" class="headerlink" title="实现分页"></a>实现分页</h2><p>首先呢也是通过算法公式计算出起始位置以及终点位置(页头,页尾)</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">info = UserModel.object.all().values() </span></span><br><span class="line"><span class="xml">start = (int(page) - 1) * size  # 起始位置</span></span><br><span class="line"><span class="xml">end = page * size   # 终点位置</span></span><br><span class="line"><span class="xml">data = info[start:end]  # 这里进行切割数据返回给前端</span></span><br></pre></td></tr></table></figure><p>这样其实已经完成了分页的功能，但是这里面是有坑的，什么坑呢，就是说，你每次查询都要从头开始查询，这就导致你查询的数据量非常大，举个例子吧：比如说你有1万的用户信息，每页十条用户信息，那么你会有1000的页数，当你点击第1000页时，mysql的底层查询是从头开始查询，一直查询到你点击的1000页的数据，同理：点击999页、998页都是需要从头开始查询，那这样的话是非常浪费时间的，所以说我们可以给它进行sql优化一下。<br><br></p><p>比如说查询用户,我们直接使用where语句加条件，当id&gt;起始位置时让它直接从起始位置开始查询，这样的话直接是从起始位置开始查询的，这样就节省了很大的空间，我们这边直接使用sql语句进行查询。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id &gt; start limit start,end</span><br></pre></td></tr></table></figure><p><br><br></p><p>使用sql语句查询后，接下来演示一下使用orm语句来查询用户</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">User.objects.filter(id__gte=start).values()[0:10]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alipay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步发请求</title>
      <link href="/2020/10/23/a_id_17/"/>
      <url>/2020/10/23/a_id_17/</url>
      
        <content type="html"><![CDATA[<h3 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">import httpx</span></span><br><span class="line"><span class="xml">import asyncio</span></span><br><span class="line"><span class="xml">import time</span></span><br><span class="line"></span><br><span class="line"><span class="xml">url = &#x27;http://127.0.0.1:8000/userapp/all/&#x27;  # 记录url</span></span><br><span class="line"></span><br><span class="line"><span class="xml">data = &#123;&#x27;username&#x27;: &#x27;username&#x27;, &#x27;new_of_username&#x27;: &#x27;123&#x27;&#125;  # 参数</span></span><br><span class="line"></span><br><span class="line"><span class="xml">start = time.time()  # 记录开始时间</span></span><br><span class="line"><span class="xml">for i in range(100):</span></span><br><span class="line"><span class="xml">    g = httpx.get(url)  # 展示</span></span><br><span class="line"><span class="xml">    print(g.text)</span></span><br><span class="line"><span class="xml">end = time.time()# 记录结束时间</span></span><br><span class="line"><span class="xml">print(f&quot;同步请求花费时间：&#123;end - start&#125;&quot;)</span></span><br></pre></td></tr></table></figure><h3 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">async def Perform(client):</span></span><br><span class="line"><span class="xml">    r = await client.get(url)</span></span><br><span class="line"><span class="xml">    print(r.text)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="xml">async def main():</span></span><br><span class="line"><span class="xml">    async with httpx.AsyncClient() as client:</span></span><br><span class="line"><span class="xml">        data = []</span></span><br><span class="line"><span class="xml">        for i in range(100):</span></span><br><span class="line"><span class="xml">            info = Perform(client)</span></span><br><span class="line"><span class="xml">            res = asyncio.create_task(info)</span></span><br><span class="line"><span class="xml">            data.append(res)</span></span><br><span class="line"><span class="xml">        await asyncio.gather(*data)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="xml">start_ = time.time()</span></span><br><span class="line"><span class="xml">asyncio.run(main())</span></span><br><span class="line"><span class="xml">end_ = time.time()</span></span><br><span class="line"><span class="xml">print(f&quot;异步请求花费时间：&#123;end_ - start_&#125;&quot;)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alipay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Websocket实现在线人数统计</title>
      <link href="/2020/10/12/a_id_16/"/>
      <url>/2020/10/12/a_id_16/</url>
      
        <content type="html"><![CDATA[<h2 id="使用WebSocket实现在线统计人数"><a href="#使用WebSocket实现在线统计人数" class="headerlink" title="使用WebSocket实现在线统计人数"></a>使用WebSocket实现在线统计人数</h2><h4 id="封装Redis方法-尽量封装类"><a href="#封装Redis方法-尽量封装类" class="headerlink" title="封装Redis方法 (尽量封装类)"></a>封装Redis方法 (尽量封装类)</h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">import redis</span></span><br><span class="line"></span><br><span class="line"><span class="xml">class MrRedis:</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    def __init__(self, **kwargs):</span></span><br><span class="line"><span class="xml">        self.__db = redis.Redis(**kwargs)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    def set(self, key, value):</span></span><br><span class="line"><span class="xml">        self.__db.set(key, value)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    def sety(self, key, value, count):  # set方法 + 过期时间</span></span><br><span class="line"><span class="xml">        self.__db.set(key, value, count)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    def get(self, value):</span></span><br><span class="line"><span class="xml">        return self.__db.get(value)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    def sadd(self, key, value):</span></span><br><span class="line"><span class="xml">        self.__db.sadd(key, value)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    def scard(self, value):</span></span><br><span class="line"><span class="xml">        return self.__db.scard(value)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    def expire(self, key, value):</span></span><br><span class="line"><span class="xml">        self.__db.expire(key, value)</span></span><br></pre></td></tr></table></figure><h4 id="使用websocket建立长连接"><a href="#使用websocket建立长连接" class="headerlink" title="使用websocket建立长连接"></a>使用websocket建立长连接</h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">@accept_websocket</span></span><br><span class="line"><span class="xml">def test_websocket(request, pk):</span></span><br><span class="line"><span class="xml">    while 1:</span></span><br><span class="line"><span class="xml">        if request.is_websocket():</span></span><br><span class="line"><span class="xml">            time.sleep(0.1)  # 间隔时间返回</span></span><br><span class="line"><span class="xml">   request.websocket.send(json.dumps(&#123;&#x27;count&#x27;: MrRedis().scard(&#x27;set_i&#x27;)&#125;))</span></span><br></pre></td></tr></table></figure><h4 id="实现计算人数"><a href="#实现计算人数" class="headerlink" title="实现计算人数"></a>实现计算人数</h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">class MenCount(APIView):</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    def get(self, request):</span></span><br><span class="line"></span><br><span class="line"><span class="xml">        redis_ = MrRedis()</span></span><br><span class="line"></span><br><span class="line"><span class="xml">        if request.META.get(&#x27;HTTP_X_FORWARDED_FOR&#x27;):  # 判断是否为真实IP</span></span><br><span class="line"></span><br><span class="line"><span class="xml">            ip = request.META.get(&quot;HTTP_X_FORWARDED_FOR&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">        else:</span></span><br><span class="line"></span><br><span class="line"><span class="xml">            ip = request.META.get(&quot;REMOTE_ADDR&quot;)  # 代理IP</span></span><br><span class="line"></span><br><span class="line"><span class="xml">        if redis_.scard(&quot;set_i&quot;):  # 返回集合中元素的数量</span></span><br><span class="line"></span><br><span class="line"><span class="xml">            redis_.sadd(&#x27;set_i&#x27;, ip)  # 向集合添加元素 重复忽略</span></span><br><span class="line"></span><br><span class="line"><span class="xml">        else:  # 第一次添加</span></span><br><span class="line"></span><br><span class="line"><span class="xml">            redis_.sadd(&#x27;set_i&#x27;, ip)</span></span><br><span class="line"><span class="xml">            redis_.expire(&#x27;set_i&#x27;, 300)  # 设置5分钟不在消失</span></span><br><span class="line"></span><br><span class="line"><span class="xml">        return Response(&#123;&#x27;count&#x27;: redis_.scard(&#x27;set_i&#x27;)&#125;)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alipay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webshell</title>
      <link href="/2020/09/11/a_id_15/"/>
      <url>/2020/09/11/a_id_15/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是webshell"><a href="#一、什么是webshell" class="headerlink" title="一、什么是webshell"></a>一、什么是webshell</h2><ul><li><p>webshell简介</p><p>webshell，顾名思义：web指的是web服务器上，而shell，是用脚本语言编写的脚本程序，webshell就是web的一个管理工具，可以对web服务器进行操作的权限，也叫webadmin。webshell一般是被网站管理员用于网站管理、服务器管理等等一些用途，但是由于webshell的功能比较强大，可以上传下载文件，查看数据库，甚至可以调用一些服务器上系统的相关命令，通常被黑客利用，黑客通过一些上传方式，将自己编写的webshell上传到web服务器的页面的目录下，然后通过页面访问的形式进行入侵，或者通过插入一句话连接本地的一些相关工具直接对服务器进行入侵操作。  </p></li><li><p>webshell分类</p><p>webshell根据脚本可以分为PHP脚本木马，ASP脚本木马，也有基于.NET的脚本木马和JSP脚本木马。在国外，还有用python脚本语言写的动态网页，当然也有与之相关的webshell。<br>根据功能也分为大马与小马，小马通常指的一句话木马，例如：&lt;%eval request(“pass”)%&gt;通常把这句话写入一个文档里面，然后文件名改成xx.asp。然后传到服务器上面。这里eval方法将request(“pass”)转换成代码执行，request函数的作用是应用外部文件。这相当于一句话木马的客户端配置。  </p></li></ul><h2 id="二、实践"><a href="#二、实践" class="headerlink" title="二、实践"></a>二、实践</h2><p>使用webshell在浏览器实现黑窗口</p><h4 id="2-1-首先下载"><a href="#2-1-首先下载" class="headerlink" title="2.1 首先下载"></a>2.1 首先下载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install xterm@3.1.0 –save</span><br></pre></td></tr></table></figure><h4 id="2-2-在Vue页面中导入包"><a href="#2-2-在Vue页面中导入包" class="headerlink" title="2.2 在Vue页面中导入包"></a>2.2 在Vue页面中导入包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import * as attach from &quot;xterm&#x2F;lib&#x2F;addons&#x2F;attach&#x2F;attach&quot;; &#x2F;&#x2F; 安装插件可以使用attach添加</span><br><span class="line">import * as fit from &quot;xterm&#x2F;lib&#x2F;addons&#x2F;fit&#x2F;fit&quot;; &#x2F;&#x2F;  黑窗口可以自适度屏幕大小</span><br><span class="line">import &#123; coursedetail &#125; from &quot;@&#x2F;http&#x2F;api&quot;; &#x2F;&#x2F;  导入请求</span><br><span class="line"></span><br><span class="line">Terminal.applyAddon(attach); &#x2F;&#x2F; 添加插件</span><br><span class="line">Terminal.applyAddon(fit); &#x2F;&#x2F; 插件</span><br></pre></td></tr></table></figure><h4 id="2-3-初始化div对象"><a href="#2-3-初始化div对象" class="headerlink" title="2.3 初始化div对象"></a>2.3 初始化div对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">    &#x2F;&#x2F;  获取div标签</span><br><span class="line">    let terminalLcontainer &#x3D; document.getElementById(&quot;terminal&quot;);</span><br><span class="line">    &#x2F;&#x2F;  初始化对象</span><br><span class="line">    this.term &#x3D; new Terminal(this.termail);</span><br><span class="line">    &#x2F;&#x2F;  打开对象</span><br><span class="line">    this.term.open(terminalLcontainer); </span><br><span class="line"> </span><br><span class="line">    this.terminalSocket &#x3D; new WebSocket(&quot;ws:&#x2F;&#x2F;127.0.0.1:8000&#x2F;course&#x2F;webssh&#x2F;&quot;);</span><br><span class="line">    this.terminalSocket.onopen &#x3D; function() &#123;</span><br><span class="line">      &#x2F;&#x2F; 连接成功触发该方法</span><br><span class="line">      this.term_status &#x3D; true</span><br><span class="line">      console.log(&quot;websocket is Connected...&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    this.terminalSocket.onclose &#x3D; function() &#123;</span><br><span class="line">      &#x2F;&#x2F; 连接关闭适触发的方法</span><br><span class="line">      console.log(&quot;websocket is Closed...&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    this.terminalSocket.onerror &#x3D; function() &#123;</span><br><span class="line">      &#x2F;&#x2F; 连接出错触发的方法</span><br><span class="line">      console.log(&quot;damn Websocket is broken!&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    this.term.attach(this.terminalSocket)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-下载dwebsocket"><a href="#2-4-下载dwebsocket" class="headerlink" title="2.4 下载dwebsocket"></a>2.4 下载dwebsocket</h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">pip install dwebsocket</span></span><br></pre></td></tr></table></figure><p>在settings中配置<br><img src="/.top//4.1.jpg"></p><h4 id="2-5-初始化一个ssh对象"><a href="#2-5-初始化一个ssh对象" class="headerlink" title="2.5 初始化一个ssh对象"></a>2.5 初始化一个ssh对象</h4><p><img src="/.top//4.2.jpg"></p><h4 id="2-6-建立ssh连接通道"><a href="#2-6-建立ssh连接通道" class="headerlink" title="2.6 建立ssh连接通道"></a>2.6 建立ssh连接通道</h4><p><img src="/.top//4.4.jpg"></p><h4 id="2-7-启动"><a href="#2-7-启动" class="headerlink" title="2.7 启动"></a>2.7 启动</h4><p><img src="/.top//4.3.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alipay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象封装Redis</title>
      <link href="/2020/08/20/a_id_14/"/>
      <url>/2020/08/20/a_id_14/</url>
      
        <content type="html"><![CDATA[<h3 id="封装Redis"><a href="#封装Redis" class="headerlink" title="封装Redis"></a>封装Redis</h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">import redis</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="xml">class MrRedis:</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    def __init__(self, **kwargs):</span></span><br><span class="line"><span class="xml">        self.__db = redis.Redis(**kwargs, decode_responses=True)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    def set(self, key, value):</span></span><br><span class="line"><span class="xml">        self.__db.set(key, value)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    def sety(self, key, value, count):  # set方法 + 过期时间</span></span><br><span class="line"><span class="xml">        self.__db.set(key, value, count)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    def get(self, value):</span></span><br><span class="line"><span class="xml">        return self.__db.get(value)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    def sadd(self, key, value):</span></span><br><span class="line"><span class="xml">        self.__db.sadd(key, value)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    def scard(self, value):</span></span><br><span class="line"><span class="xml">        return self.__db.scard(value)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    def expire(self, key, value):</span></span><br><span class="line"><span class="xml">        self.__db.expire(key, value)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alipay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql联合索引</title>
      <link href="/2020/08/13/a_id_13/"/>
      <url>/2020/08/13/a_id_13/</url>
      
        <content type="html"><![CDATA[<h1 id="关于mysql联合索引的最左前缀原则以及b-tree"><a href="#关于mysql联合索引的最左前缀原则以及b-tree" class="headerlink" title="关于mysql联合索引的最左前缀原则以及b+tree"></a>关于mysql联合索引的最左前缀原则以及b+tree</h1><p style="font-size:23px">查询条件要符合最左原则才能使用到索引</p><br><p style="font-size:23px">首先介绍下联合索引</p><br>      最重要的一点是覆盖索引，非主键索引会先查到主键索引的值再从主键索引上拿到想要的值，会多一次索引下推，覆盖索引可以直接在非主键索引上拿到对应的值，减少一次查询，<br><br><p style="font-size:23px">最左查询 </p><pre><code>    也就是说先查询最左边的，在检索数据时从联合索引的最左边开始匹配，类似于给 index （name,age,gender）三个字段加上联合索引 等于加上了（name,age） （name,gender） （name,age,gender） 这三种查询优化组合 </code></pre><br><p style="font-size:23px">举个例子 </p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE pay(</span><br><span class="line">    id INT,</span><br><span class="line">    NAME  </span><br><span class="line">    index (name,age,gender)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></code></pre><br><p style="font-size:23px">这个时候可以使用EXPLAIN计划任务来查询是否命中索引,</p><p style="color:red">possible_keys</p>    根据这个字段可以解读是否命中索引, <p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM pay WHERE  NAME &#x3D; &#39;王杰&#39; AND age &#x3D; 24 AND gender &#x3D; &#39;男&#39;;</span><br><span class="line">目前这条sql语句已经出现了index索引</span><br><span class="line">idselect_typetablepartitionstypepossible_keyskeykey_lenrefrowsfilteredExtra</span><br><span class="line">1SIMPLEpay\Nref        indexindex        325const,const,const1100.00Using index</span><br></pre></td></tr></table></figure><br><p style="font-size:23px">然后我们再只根据年龄做查询看一下是否能够命中索引，很显然possible_keys    为NULL，说明并没有命中索引因为它不符合最左原则，因为它没有命中（name，age） （name，gender） （name，age，gender）这种组合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM pay WHERE  age &#x3D; 24;</span><br><span class="line">目前这条sql语句已经出现了index索引</span><br><span class="line">idselect_typetablepartitionstypepossible_keyskeykey_lenrefrowsfilteredExtra</span><br><span class="line">1SIMPLEpay\Nref        index(NULL))        325const,const,const1100.00Using index</span><br></pre></td></tr></table></figure><br><p style="font-size:23px">另外使用执行计划一定要看结果，只有possible_keys有值的情况下才是命中索引</p><br><p>还有就是where条件的顺序是否会影响索引的命中，就是本来(name,age)的组合，故意写where语句时写成(age,name)，答案是没有影响，只要遵循了索引的最左原则就可以</p>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alipay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无限极分类</title>
      <link href="/2020/07/01/a_id_12/"/>
      <url>/2020/07/01/a_id_12/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>无限极分类简单点说就是一个类可以分成多个子类，然后一个子类又可以分另外多个子类这样无限分下去，就好象windows可以新建一个文件夹，然后在这个文件夹里又可以建一些个文件夹，在文件夹底下还可以建一些文件夹一样</p><h2 id="实践操作"><a href="#实践操作" class="headerlink" title="实践操作"></a>实践操作</h2><h4 id="1-首先创建模型表"><a href="#1-首先创建模型表" class="headerlink" title="1. 首先创建模型表"></a>1. 首先创建模型表</h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">class CaiModel(models.Model):</span></span><br><span class="line"><span class="xml">    name = models.CharField(max_length=200)</span></span><br><span class="line"><span class="xml">    par = models.ForeignKey(&#x27;self&#x27;, on_delete=models.SET_NULL, null=True, blank=True)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    def __str__(self):</span></span><br><span class="line"><span class="xml">        return self.name</span></span><br></pre></td></tr></table></figure><h4 id="2-序列化器"><a href="#2-序列化器" class="headerlink" title="2. 序列化器"></a>2. 序列化器</h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">from rest_framework import serializers</span></span><br><span class="line"><span class="xml">from app1.models import CaiModel</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="xml">class CaiSerializers(serializers.ModelSerializer):</span></span><br><span class="line"><span class="xml">    class Meta:</span></span><br><span class="line"><span class="xml">        model = CaiModel</span></span><br><span class="line"><span class="xml">        fields = &#x27;__all__&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="3-写一个递归的方法"><a href="#3-写一个递归的方法" class="headerlink" title="3. 写一个递归的方法"></a>3. 写一个递归的方法</h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">def xTree(datas):</span></span><br><span class="line"><span class="xml">    lists = []  # 定义空列表</span></span><br><span class="line"><span class="xml">    tree = &#123;&#125;  # 定义空字典</span></span><br><span class="line"><span class="xml">    for i in datas:</span></span><br><span class="line"><span class="xml">        item = i</span></span><br><span class="line"><span class="xml">        tree[item[&#x27;id&#x27;]] = item</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    for i in datas:</span></span><br><span class="line"><span class="xml">        obj = i</span></span><br><span class="line"><span class="xml">        if not obj[&#x27;par&#x27;]:</span></span><br><span class="line"><span class="xml">            root = tree[obj[&#x27;id&#x27;]]</span></span><br><span class="line"><span class="xml">            lists.append(root)</span></span><br><span class="line"><span class="xml">        else:</span></span><br><span class="line"><span class="xml">            parent_id = obj[&#x27;par&#x27;]</span></span><br><span class="line"><span class="xml">            if &#x27;childlist&#x27; not in tree[parent_id]:</span></span><br><span class="line"><span class="xml">                tree[parent_id][&#x27;childlist&#x27;] = []</span></span><br><span class="line"><span class="xml">            tree[parent_id][&#x27;childlist&#x27;].append(tree[obj[&#x27;id&#x27;]])</span></span><br><span class="line"><span class="xml">    return lists</span></span><br></pre></td></tr></table></figure><h4 id="4-写一个视图函数-接收数据"><a href="#4-写一个视图函数-接收数据" class="headerlink" title="4. 写一个视图函数, 接收数据"></a>4. 写一个视图函数, 接收数据</h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">class MyTree(APIView):</span></span><br><span class="line"><span class="xml">    def get(self, request):</span></span><br><span class="line"><span class="xml">        &quot;&quot;&quot;</span></span><br><span class="line"><span class="xml">        查找</span></span><br><span class="line"><span class="xml">        :param request:</span></span><br><span class="line"><span class="xml">        :return:</span></span><br><span class="line"><span class="xml">        &quot;&quot;&quot;</span></span><br><span class="line"><span class="xml">        cai = CaiModel.objects.all()</span></span><br><span class="line"><span class="xml">        ser = CaiSerializers(cai, many=True)</span></span><br><span class="line"><span class="xml">        data = xTree(ser.data)</span></span><br><span class="line"><span class="xml">        return Response(data)</span></span><br></pre></td></tr></table></figure><h4 id="5-实现"><a href="#5-实现" class="headerlink" title="5. 实现"></a>5. 实现</h4><p><img src="/.top//5.1.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alipay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git分支管理</title>
      <link href="/2020/06/27/a_id_11/"/>
      <url>/2020/06/27/a_id_11/</url>
      
        <content type="html"><![CDATA[<h4 id="为什么使用git分支呢"><a href="#为什么使用git分支呢" class="headerlink" title="为什么使用git分支呢?"></a>为什么使用git分支呢?</h4><ul><li><p>一般情况，master主分支不做开发，master主分支只做<a href="%E9%A1%B9%E7%9B%AE%E5%AE%8C%E6%88%90%E6%97%A0%E5%BC%82%E5%B8%B8%EF%BC%8C%E5%BC%80%E5%A7%8B%E9%83%A8%E7%BD%B2%E7%9A%84%E5%8F%AB%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83">生产环境</a>。</p></li><li><p>开发一般在次分支，因为我们在开发过程中，代码避免出现Bug或者修改部分，这些问题在次分支解决，解决Bug完成后，没有任何问题，合并到master主分支</p></li><li><p>总之：master主分支只做生产环境，次分支是为了开发建立的，最后次分支没有任何异常，合并到主分支master。</p></li></ul><h4 id="分支命令"><a href="#分支命令" class="headerlink" title="分支命令"></a>分支命令</h4><p>· * 代表你当前所在的分支</p><p>查看所有分支：git    branch  -a</p><p>查看云端分支：git    branch   -r</p><p>拉取分支和代码：git pull  </p><p>切换分支: git checkout 分支名</p><ul><li><p>合并代码</p><ul><li><p>首先进入master</p><p>合并: git merge 分支名</p><p>合并后:  git push  当前分支</p><p>素质三连</p></li></ul></li></ul><pre><code>git merge特点: - 只处理一次冲突- 会记录合并的历史记录, 合并的commit 按照提交时间排列展示- 所有的过程信息更多，可能会提高之后查找问题的难度</code></pre><ul><li><p>mebase 合并特点</p><ul><li>没有多余的合并历史的记录，且合并后的 <code>commit</code> 顺序不一定按照 <code>commit</code> 的提交时间排列</li><li>更清爽一些，<code>master</code> 分支上每个 <code>commit</code> 点都是相对独立完整的功能单元</li></ul></li></ul><h4 id="合并代码总结"><a href="#合并代码总结" class="headerlink" title="合并代码总结:"></a>合并代码总结:</h4><p>  当需要保留详细的合并信息的时候建议使用git merge，特别是需要将分支合并进入master分支时；当发现自己修改某个功能时，频繁进行了git commit提交时，发现其实过多的提交信息没有必要时，可以尝试git rebase。</p><p>​       </p><h4 id="代码回退"><a href="#代码回退" class="headerlink" title="代码回退"></a>代码回退</h4><p>​    查看日志:  git log</p><p>​    回退到指定版本:  git reset  –hard  日制id</p><p>​    推送:  git push origin HEAD –force</p>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alipay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>set，zset底层实现</title>
      <link href="/2020/05/18/a_id_10/"/>
      <url>/2020/05/18/a_id_10/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis五大数据类型-Set与Zset"><a href="#Redis五大数据类型-Set与Zset" class="headerlink" title="Redis五大数据类型 Set与Zset"></a>Redis五大数据类型 Set与Zset</h1><p style="font-size:20px">Redis的set相信大家都是使用过的，set的去重也是非常的好用，相信大多数人都会使用.</p><br><br><p style="font-size:15px">比如说实现在线人数统计，我们只需要把ip扔进set里，重复的会自动去掉，但是却很少有人知道他的底层逻辑是怎么实现的呢?</p><br><br><p style="font-size:15px"> 首先呢必须有一个新的容器，用于存储新的数据，然后的话将自己的容器进行遍历判断与新的容器中数据作对比，如果存在，直接丢弃，不存在写入新的容器.<br><br></p><p style="font-size:15px">我这边举个生活中的例子，比如说买金鱼，你想要不重复的金鱼，你是不是得拿一个新盆子捞鱼，捞出来之后与容器中对比，相同的鱼扔掉，不一样放进去</p><br><p>这就是set去重逻辑底层实现!</p><br><h1 id="Zset有序集合"><a href="#Zset有序集合" class="headerlink" title="Zset有序集合"></a>Zset有序集合</h1><p style="font-size:15px">这里说一下这个有序集合这块的底层实现，有序集合大家也不陌生，因为我自己有时候也玩游戏嘛，就是一个无意间发现它这个游戏的排行榜功能，经过自己研究呢，也是完成了，我呢是使用的Redis的有序集合实现的这个排行榜功能，</p><br><h5 id="描述"><a href="#描述" class="headerlink" title="描述:"></a>描述:</h5><p style="font-size:15px">  　　我就使用用户积分做这个排行榜了，做之前也是想到了排行榜这个东西令人头疼的不是查数据，而是说排行榜随时有可能插入一个用户，通过这个可以想到数组，但是它是连续的，数据都是挨着的，线性结构，查询利用折半查找也是非常方便，非常快，但是如果向数组插数据是非常的困难的，比如说一百万的数据，我想插入中间，前面五十万得往前腾地方，后面也是往后腾地方，举个例子比如说电影院里，假如一排有一个人做错位置，那这一排的人都要动，这就是数组，插入和修改的效率及其低，反之查找的速度很快的，利用二分查找.</p><br><br><h5 id="Zset底层实现"><a href="#Zset底层实现" class="headerlink" title="Zset底层实现:"></a>Zset底层实现:</h5><p style="font-size:15px">　　因此当时我也是使用的链表，因为链表是非线性结构的，永远都是有一根指针指向地址，不需要来回腾位置，链表的好处就是随时插入数据，插入方便，当然的话链表的查询也是非常慢，链表的劣势就是说我需要遍历所有的节点来查找，有100万就要遍历一百万次，因为只有线性结构才可以使用折半查找， 解决方案的话也就是使用跳表的使用.  <br><pre><code>什么是跳表呢?(以空间换时间)跳表就是跳跃表，使用位运算对奇数抽出比如说:  　　 第一次跳 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7 　　 第二次跳 1-&gt;3-&gt;5-&gt;7  第二次这里使用位运算抽取出奇数的数查取  　　 第三次跳 1-&gt;7     </code></pre></p><br><h3 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h3><ul><li><p>set集合的底层逻辑已经在上面写好了  </p></li><li><p>排行榜功能由Redis-&gt;Zadd(有序集合)-&gt;链表-&gt;跳表</p></li><li><p> 链表的内存地址是随机的，由指针指向，好处就是，插入和修改方便，不考虑位置关系 </p></li><li><p>因为链表是非线性结构，无法使用折半查找， 查询慢</p></li></ul><br>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alipay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>唯一索引与Docker基操</title>
      <link href="/2020/05/10/a_id_9/"/>
      <url>/2020/05/10/a_id_9/</url>
      
        <content type="html"><![CDATA[<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><ul><li><p>唯一索引干嘛用的</p><p>应用场景：用户注册的用户名，手机号，邮箱，身份证信息，学号等场景</p></li><li><p>为什么使用唯一索引</p><p>唯一索引就是该字段数据不能重复，可以有一个为空，只要不重复就可以，与主键不同的是，一张表中只能有一个主键，主键不能为空，使用唯一索引的好处就是可以避免数据重复出现，也是提高了访问速度.</p></li></ul><h3 id="Docker操作基本命令"><a href="#Docker操作基本命令" class="headerlink" title="Docker操作基本命令"></a>Docker操作基本命令</h3><ul><li><p>启动docker服务</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure></li><li><p>停止docker服务</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure></li><li><p>重启docker服务</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure></li><li><p>拉取镜像</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 镜像名</span><br></pre></td></tr></table></figure></li><li><p>查看镜像 -a:本地所有镜像  -q: 显示镜像id</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images -a </span><br></pre></td></tr></table></figure></li><li><p>创建容器 </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-p指定端口映射 -P随机端口映射</span><br><span class="line">docker run -d -p 映射端口:端口号 镜像id</span><br></pre></td></tr></table></figure></li><li><p>启动容器</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器id</span><br></pre></td></tr></table></figure></li><li><p>关闭容器</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器id</span><br></pre></td></tr></table></figure></li><li><p>重启容器</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart 容器id</span><br></pre></td></tr></table></figure></li><li><p>查看正在启动的容器</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure></li><li><p>查看所有的容器 </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure></li><li><p>删除镜像</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 镜像id</span><br></pre></td></tr></table></figure></li><li><p>删除容器 参数: -f 强删</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 容器id</span><br></pre></td></tr></table></figure></li><li><p>查看容器日志 </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-f : 查看实时日志</span><br><span class="line">-t : 查看日志产生的日期</span><br><span class="line">docker logs 容器id</span><br></pre></td></tr></table></figure></li></ul><p>​<br>​    </p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alipay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL</title>
      <link href="/2020/04/24/a_id_8/"/>
      <url>/2020/04/24/a_id_8/</url>
      
        <content type="html"><![CDATA[<h1 id="前几天在leetcode上做题的时候，无意发现一道这样的需求题-如何使用一条sql语句查询出所有部门的平均工资以及每个部门个人工资的对比。"><a href="#前几天在leetcode上做题的时候，无意发现一道这样的需求题-如何使用一条sql语句查询出所有部门的平均工资以及每个部门个人工资的对比。" class="headerlink" title="前几天在leetcode上做题的时候，无意发现一道这样的需求题,如何使用一条sql语句查询出所有部门的平均工资以及每个部门个人工资的对比。"></a>前几天在leetcode上做题的时候，无意发现一道这样的需求题,如何使用一条sql语句查询出所有部门的平均工资以及每个部门个人工资的对比。</h1><p><br><br></p><p>首先我们先创建下部门表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE department(</span><br><span class="line">    id int, </span><br><span class="line">    deptname varchar(100),</span><br><span class="line">    salary int</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>然后的话我们直接给它添加测试数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO department</span><br><span class="line">values(1,&#39;技术部&#39;,13000),</span><br><span class="line">(2,&#39;技术部&#39;,16000),</span><br><span class="line">(3,&#39;行政&#39;,8000),</span><br><span class="line">(4,&#39;行政&#39;,5000)</span><br></pre></td></tr></table></figure><p><br><br></p><p>这里是展示数据展示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id | depname | userid | salary</span><br><span class="line">----+---------+--------+--------</span><br><span class="line"> 1 | 技术部  |      1 |  13000</span><br><span class="line"> 2 | 技术部  |      2 |  16000</span><br><span class="line"> 3 | 行政    |      8 |   8000</span><br><span class="line"> 4 | 行政    |      9 |   5000</span><br></pre></td></tr></table></figure><p><br><br></p><p>那么怎么实现上面的需求呢？ sql语句可以这样写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">select department.id,department.depname,department.salary,newtable.avsa</span><br><span class="line"></span><br><span class="line">-&gt; from department</span><br><span class="line"></span><br><span class="line">-&gt; inner join</span><br><span class="line"></span><br><span class="line">-&gt; (</span><br><span class="line"></span><br><span class="line">-&gt; select depname,avg(salary) as avsa from department group by depname</span><br><span class="line"></span><br><span class="line">-&gt; )</span><br><span class="line"></span><br><span class="line">-&gt; as newtable</span><br><span class="line"></span><br><span class="line">-&gt; on department.depname &#x3D; newtable.depname;</span><br></pre></td></tr></table></figure><p><br><br></p><p>这样的就查询出来了，该题概括mysql知识点也是非常全面，像聚合索引、分组、子查询等都涉及到了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+----+-----------+--------+------------+</span><br><span class="line">| id | depname   | salary | avsa       |</span><br><span class="line">+----+-----------+--------+------------+</span><br><span class="line">|  1 | 技术部    |  15000 | 15500.0000 |</span><br><span class="line">|  2 | 技术部    |  16000 | 15500.0000 |</span><br><span class="line">|  3 | 行政      |   8000 |  6500.0000 |</span><br><span class="line">|  4 | 行政      |   5000 |  6500.0000 |</span><br><span class="line">+----+-----------+--------+------------+</span><br></pre></td></tr></table></figure><p><br><br><br><br>小结：这样的话确实是把我们想要的答案查询出来，但是的sql语句未必显得有点麻烦，下面介绍另一款数据库。</p><p><br><br></p><h1 id="PostgreSQL是一种数据库管理系统，支持大部分的SQL标准并且提供了很多其他现代特性，如复杂查询、外键、触发器、视图、事务完整性、多版本并发控制等，并且这款数据库也是免费使用的"><a href="#PostgreSQL是一种数据库管理系统，支持大部分的SQL标准并且提供了很多其他现代特性，如复杂查询、外键、触发器、视图、事务完整性、多版本并发控制等，并且这款数据库也是免费使用的" class="headerlink" title="PostgreSQL是一种数据库管理系统，支持大部分的SQL标准并且提供了很多其他现代特性，如复杂查询、外键、触发器、视图、事务完整性、多版本并发控制等，并且这款数据库也是免费使用的"></a>PostgreSQL是一种数据库管理系统，支持大部分的SQL标准并且提供了很多其他现代特性，如复杂查询、外键、触发器、视图、事务完整性、多版本并发控制等，并且这款数据库也是免费使用的</h1><p><img src="/.top//04/24/a_id_8/post.png"></p><p style="font-size:23px">我们直接在Docker上安装<b>PostgreSQL</b>数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull postgres:11.1</span><br></pre></td></tr></table></figure><br><p style="font-size:23px">拉取成功后可以查看下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><br><p style="font-size:23px">然后的话我们就可以启动容器啦</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name dev-postgres -e POSTGRES_PASSWORD&#x3D;root -p 5432:5432 postgres:11.1</span><br></pre></td></tr></table></figure><br><p style="font-size:23px">我们直接exec进入容器内部的命令行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it dev-postgres bash psql -h localhost -U postgres</span><br></pre></td></tr></table></figure><br><p style="font-size:23px">在命令行输入 \l 查看数据库列表</p><p><img src="/.top//04/24/a_id_8/1.png"></p><br><p style="font-size:23px"> 使用数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\c mytest</span><br></pre></td></tr></table></figure><br><p style="font-size:23px"> 建立表</p><p><img src="/.top//04/24/a_id_8/2.png"></p><br><p style="font-size:23px"> \d查看表</p><br><p style="font-size:23px">over子句的应用，假设我们有一个员工薪资的表（部门、员工id，工资）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id | depname | userid | salary</span><br><span class="line"> ----+---------+--------+--------</span><br><span class="line"> 1 | 技术部  |      1 |  15000</span><br><span class="line"> 2 | 技术部  |      2 |  20000</span><br><span class="line"> 3 | 行政    |      8 |   4000</span><br><span class="line"> 4 | 行政    |      9 |   8000</span><br></pre></td></tr></table></figure><br><p style="font-size:23px">还是根据我们上面的需求题,现在我想将每一个员工的工资与他所在部门的平均工资做个比较，怎么做？来看下如何实现,这也是leetcode原题,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT depname,userid,salary,avg(salary) OVER (PARTITION BY depname) FROM AG;</span><br></pre></td></tr></table></figure>    <p style="font-size:23px">        查询结果：<pre><code>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> depname | userid | salary |          avg</span><br><span class="line"> ---------+--------+--------+-----------------------</span><br><span class="line">技术部  |      1 |  15000 |    17500.000000000000</span><br><span class="line">技术部  |      2 |  20000 |    17500.000000000000</span><br><span class="line">行政    |      8 |   4000 | 6000.0000000000000000</span><br><span class="line">行政    |      9 |   8000 | 6000.0000000000000000</span><br></pre></td></tr></table></figure>&lt;/p&gt;</code></pre></p><p style="font-size:23px">        使用容器启动数据库会有个问题，就是每次容器停止，数据就会丢失，所有我们可以用docker的挂载命令将数据存在宿主机中，这样就可以持久化保存数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name dev-postgres -e POSTGRES_PASSWORD&#x3D;root -e PGDATA&#x3D;&#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data&#x2F;pgdata</span><br><span class="line">-v &#x2F;custom&#x2F;mount:&#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data  -p 6432:5432 postgres:11.1</span><br></pre></td></tr></table></figure><br><br><p style="font-size:23px">        结论：自从Mysql被Oracle收购的时候，它已经不是开源的最佳选择，所以说可以适当的走向PostgreSQL！</p><p><br><br><br><br><br><br><br><br><br><br><br><br><br></p>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alipay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLserver简介</title>
      <link href="/2020/03/30/a_id_7/"/>
      <url>/2020/03/30/a_id_7/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL-Server数据库"><a href="#SQL-Server数据库" class="headerlink" title="SQL Server数据库"></a>SQL Server数据库</h1><p>sqlserver数据库是一种关系型数据库，他是一个可扩展性、高性能的数据库管理系统</p><h3 id="主要特征"><a href="#主要特征" class="headerlink" title="主要特征"></a>主要特征</h3><ol><li><p> 高性能设计，可充分利用WindosNT的优势。 （windowsNT指的是微软公司的网络操作系统）</p></li><li><p> 系统管理先进，支持Windows图形化管理工具，支持本地和远程的系统管理和配置。</p></li><li><p>处理事务功能强大，极大的可以保证数据的完整性。</p></li></ol><h3 id="SQL与SQL-Server区别"><a href="#SQL与SQL-Server区别" class="headerlink" title="SQL与SQL Server区别"></a>SQL与SQL Server区别</h3><ol><li><p>SQL是数据库查询语言，是一种用于数据库操作的语言，被作为关系型数据库的标准，能查询，能操作数据库。</p></li><li><p>SQL Server是微软开发的小型关系数据库管理系统。</p></li><li><p>Oracle则是大型关系数据库管理系统，是目前最流行的关系数据库管理系统。</p></li></ol><h3 id="SQL-Server优缺点"><a href="#SQL-Server优缺点" class="headerlink" title="SQL Server优缺点"></a>SQL Server优缺点</h3><ul><li><p>优点： </p><ul><li>扩展性强：当系统要更高数据库处理速度时，只要简单地增加数据库服务器就可以得到扩展。</li><li>可维护性： 也就是说当某个节点发生问题的时候，系统能够自动检测并转移出现问题的应用，保证数据库能够继续工作。</li><li>安全性：因为数据会同步到多台服务器上，可以实现数据的冗余（冗余就是一个表中可能会出现重复的字段，通过多份数据来保证安全性，另外它成功地将数据库放到了内网中，更好的保证了数据库的安全性。</li></ul></li><li><p>缺点：</p><ul><li>不能按照Web服务器的处理能力来分配负载</li><li>负载均衡器（控制端）如果出现故障会导致整个数据库系统瘫痪</li></ul></li></ul><h3 id="Sql-Server数据库的基本操作"><a href="#Sql-Server数据库的基本操作" class="headerlink" title="Sql Server数据库的基本操作"></a>Sql Server数据库的基本操作</h3><ul><li><p>创建数据库 </p><p> CREATE DATABASE 数据库名</p></li><li><p>进入数据库</p><p> USE 数据库名</p></li><li><p>创建表</p><p>CREATE TABLE 表名</p></li><li><p>删除表</p><p>DROP  table 表名</p></li><li><p>简单基本sql语句</p><ul><li>选择： select * from 表名 where 条件</li><li>插入： insert into 表名(字段名1，字段名2)  Value(值1，值2)</li><li>删除： delete from 表名 where 条件</li><li>更新： update 表名 set 字段名=值 where 条件</li><li>求和： select sum(age) from 表名         #  最大，最小值等类似</li><li>查找：select * from 表名 order by age(根据年龄排序)     #  desc 降序，asc升序，默认升序</li></ul></li><li><p>主键约束：</p><ul><li>alter table 表名 add constraint 约束名称 primary key(列名）</li></ul></li><li><p>unique约束：</p><ul><li>alter table 表名 add constraint 约束名称unique(列名);</li></ul></li><li><p>外键约束</p><ul><li>alter table 表名 add constraint 约束名称 约束类型 (列名) references 被引用的表名称 （列名）</li></ul></li></ul><p><img src="/.top//OIP.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alipay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB数据库</title>
      <link href="/2019/08/14/a_id_6/"/>
      <url>/2019/08/14/a_id_6/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是MongoDB"><a href="#什么是MongoDB" class="headerlink" title="什么是MongoDB ?"></a>什么是MongoDB ?</h2><p>MongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。</p><p>MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</p><h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ul><li>MongoDB 是一个面向文档存储的数据库，操作起来比较简单和容易。</li><li>MongoDB支持各种编程语言:RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。</li><li>MongoDB安装简单。</li></ul><h3 id="Mongdb超时索引介绍"><a href="#Mongdb超时索引介绍" class="headerlink" title="Mongdb超时索引介绍"></a>Mongdb超时索引介绍</h3><p><strong><em>\</em>mongos&gt; db.eventlog.createIndex( { “lastModifiedDate”: 1 }, { expireAfterSeconds: 60 } )**</strong><br><strong><em>\</em>{**</strong><br><strong><em>\</em>“ok” : 1**</strong><br><strong><em>\</em>}**</strong></p><p>\2. 插入4条记录<br><em>mongos&gt; db.eventlog.insert({“title”:”mongodb 1”,”lastModifiedDate”:new Date()})</em><br><em>WriteResult({ “nInserted” : 1 })</em><br><em>mongos&gt; db.eventlog.insert({“title”:”mongodb 2”,”lastModifiedDate”:new Date()})</em><br><em>WriteResult({ “nInserted” : 1 })</em><br><em>mongos&gt; db.eventlog.insert({“title”:”mongodb 3”,”lastModifiedDate”:new Date()})</em><br><em>WriteResult({ “nInserted” : 1 })</em><br><em>mongos&gt; db.eventlog.insert({“title”:”mongodb 4”,”lastModifiedDate”:new Date()})</em></p><p>\3. 查询记录</p><p><em>mongos&gt; db.eventlog.find()</em><br><em>{ “_id” : ObjectId(“5a9697a671d2645a6fa3f9cb”), “title” : “mongodb 1”, “lastModifiedDate” : ISODate(“2018-02-28T11:51:02.804Z”) }</em><br><em>{ “_id” : ObjectId(“5a9697aa71d2645a6fa3f9cc”), “title” : “mongodb 2”, “lastModifiedDate” : ISODate(“2018-02-28T11:51:06.393Z”) }</em><br><em>{ “_id” : ObjectId(“5a9697ad71d2645a6fa3f9cd”), “title” : “mongodb 3”, “lastModifiedDate” : ISODate(“2018-02-28T11:51:09.416Z”) }</em><br><em>{ “_id” : ObjectId(“5a9697c671d2645a6fa3f9ce”), “title” : “mongodb 4”, “lastModifiedDate” : ISODate(“2018-02-28T11:51:34.499Z”) }</em></p><p>大概过了90s，再查询<br><em>mongos&gt; db.eventlog.find()</em><br><em>mongos&gt;</em></p><p>果然同时消失了，说明执行超时删除不是实时的，而是60秒执行一次。</p><h3 id="Mongodb数据库安装"><a href="#Mongodb数据库安装" class="headerlink" title="Mongodb数据库安装"></a>Mongodb数据库安装</h3><p>1、Mongodb数据库官网</p><p>[<a href="http://www.mongodb.com]">http://www.mongodb.com]</a>: </p><h3 id="Mongodb基操作"><a href="#Mongodb基操作" class="headerlink" title="Mongodb基操作"></a>Mongodb基操作</h3><p>1、进入数据库命令</p><blockquote><p>mongodb</p></blockquote><p>2、创建数据库</p><blockquote><p>use 数据库名</p></blockquote><p>3、查看当前数据库</p><blockquote><p>db</p></blockquote><p>4、查看所有数据库</p><blockquote><p>dbs</p></blockquote><p>5、insert() 插入数据</p><blockquote><p>db.workcate.insert({‘name’:’王杰’}) </p><p>db.表名.insert({‘name’:’王杰’}) </p></blockquote><p>6、insertMany() 插入多条数据</p><blockquote><p>db.cao.insertMany([{name:”cao”},{name:”yuan”},{name:”caopeng”}])</p></blockquote><p>7、查看数据</p><blockquote><p>db.表名.find({条件})</p><p>db.表名.find(条件).preety()  # 树状型展示</p></blockquote><p>8、修改表数据</p><blockquote><p>db.表名.update({‘name’：’王杰}，$set：{‘name’：‘王’})</p><p>例子：将所有年龄大于20的改为18</p><p>db.class0.update({age:{$gt:20}},{$set:{age:18}},false,true)</p></blockquote><p>9、查看表名字</p><blockquote><p>db.getCollectionNames()</p></blockquote><p>10、查看数据库名</p><blockquote><p>db.getName()</p></blockquote><h2 id="mongodb常用查询语句"><a href="#mongodb常用查询语句" class="headerlink" title="mongodb常用查询语句"></a>mongodb常用查询语句</h2><p>1、查询所有记录<br>db.userInfo.find();<br>相当于：select* from userInfo;</p><p>2、查询去掉后的当前聚集集合中的某列的重复数据<br>db.userInfo.distinct(“name”);<br>会过滤掉 name 中的相同数据<br>相当于：select distict name from userInfo;</p><p>3、查询 age = 22 的记录<br>db.userInfo.find({“age”: 22});<br>相当于： select * from userInfo where age = 22;</p><p>4、查询 age &gt; 22 的记录<br>db.userInfo.find({age: {$gt: 22}});<br>相当于：select * from userInfo where age &gt;22;</p><p>5、查询 age &lt; 22 的记录<br>db.userInfo.find({age: {$lt: 22}});<br>相当于：select * from userInfo where age &lt;22;</p><p>6、查询 age &gt;= 25 的记录<br>db.userInfo.find({age: {$gte: 25}});<br>相当于：select * from userInfo where age &gt;= 25;</p><p>7、查询 age &lt;= 25 的记录<br>db.userInfo.find({age: {$lte: 25}});</p><p>8、查询 age &gt;= 23 并且 age &lt;= 26 注意书写格式<br>db.userInfo.find({age: {$gte: 23, $lte: 26}});</p><p>9、查询 name 中包含 mongo 的数据 模糊查询用于搜索<br>db.userInfo.find({name: /mongo/});<br>//相当于%%<br>select * from userInfo where name like ‘%mongo%’;</p><p>10、查询 name 中以 mongo 开头的<br>db.userInfo.find({name: /^mongo/});<br>select * from userInfo where name like ‘mongo%’;</p><p>11、查询指定列 name、age 数据<br>db.userInfo.find({}, {name: 1, age: 1});<br>相当于：select name, age from userInfo;<br>当然 name 也可以用 true 或 false,当用 ture 的情况下河 name:1 效果一样，如果用 false 就<br>是排除 name，显示 name 以外的列信息。</p><p>12、查询指定列 name、age 数据, age &gt; 25<br>db.userInfo.find({age: {$gt: 25}}, {name: 1, age: 1});<br>相当于：select name, age from userInfo where age &gt;25;</p><p>13、按照年龄排序 1 升序 -1 降序<br>升序：db.userInfo.find().sort({age: 1});<br>降序：db.userInfo.find().sort({age: -1});</p><p>14、查询 name = zhangsan, age = 22 的数据<br>db.userInfo.find({name: ‘zhangsan’, age: 22});<br>相当于：select * from userInfo where name = ‘zhangsan’ and age = ‘22’;</p><p>15、查询前 5 条数据<br>db.userInfo.find().limit(5);<br>相当于：selecttop 5 * from userInfo;</p><p>16、查询 10 条以后的数据<br>db.userInfo.find().skip(10);<br>相当于：select * from userInfo where id not in (<br>selecttop 10 * from userInfo<br>);</p><p>17、查询在 5-10 之间的数据<br>db.userInfo.find().limit(10).skip(5);<br>可用于分页，limit 是 pageSize，skip 是第几页*pageSize</p><p>18、or 与 查询<br>db.userInfo.find({$or: [{age: 22}, {age: 25}]});<br>相当于：select * from userInfo where age = 22 or age = 25;</p><p>19、findOne 查询第一条数据<br>db.userInfo.findOne();<br>相当于：selecttop 1 * from userInfo;<br>db.userInfo.find().limit(1);</p><p>20、查询某个结果集的记录条数 统计数量<br>db.userInfo.find({age: {$gte: 25}}).count();<br>相当于：select count(*) from userInfo where age &gt;= 20;<br>如果要返回限制之后的记录数量，要使用 count(true)或者 count(非 0)<br>db.users.find().skip(10).limit(5).count(true);</p>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alipay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker操作容器、镜像、dockerfile</title>
      <link href="/2019/08/03/a_id_5/"/>
      <url>/2019/08/03/a_id_5/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Docker容器"><a href="#一、Docker容器" class="headerlink" title="一、Docker容器"></a>一、Docker容器</h1><p>Docker 容器是一个开源的应用容器引擎，让开发者可以以统一的方式打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何安装了docker引擎的服务器上（包括流行的<a href="https://baike.baidu.com/item/Linux">Linux</a>机器、windows机器），也可以实现<a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%8C%96/547949">虚拟化</a>。容器是完全使用<a href="https://baike.baidu.com/item/%E6%B2%99%E7%AE%B1/393318">沙箱</a>机制，相互之间不会有任何接口。几乎没有性能开销,可以很容易地在机器和数据中心中运行。最重要的是,他们不依赖于任何语言、框架包括系统。</p><h1 id="二、linux下安装docker容器"><a href="#二、linux下安装docker容器" class="headerlink" title="二、linux下安装docker容器"></a>二、linux下安装docker容器</h1><ul><li><p>2.1 使用yum源安装即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install docker</span><br></pre></td></tr></table></figure></li><li><p> 2.2 启动docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure></li><li><p> 2.3 查看docker服务状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure><p>以下就是说明安装成功</p><p><img src="/.top//7.1.jpg"></p></li></ul><h1 id="三、Docker-下载镜像"><a href="#三、Docker-下载镜像" class="headerlink" title="三、Docker 下载镜像"></a>三、Docker 下载镜像</h1><ul><li><p>3.1 下载镜像</p><p>例如: 下载Mysql5.7镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure></li><li><p>3.2 验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure></li><li><p>3.3 pull子命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull --help</span><br></pre></td></tr></table></figure><p>出现很多信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@iZbp1j8y1bab0djl9gdp33Z ~]# docker pull --help</span><br><span class="line"></span><br><span class="line">Usage:  docker pull [OPTIONS] NAME[:TAG|@DIGEST]</span><br><span class="line"></span><br><span class="line">Pull an image or a repository from a registry</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -a, --all-tags                Download all tagged images in the repository</span><br><span class="line">      --disable-content-trust   Skip image verification (default true)</span><br><span class="line">      --help                    Print usage</span><br></pre></td></tr></table></figure><ol><li><code>-a, --all-tags=true|false</code>: 是否获取仓库中所有镜像，默认为否；</li><li><code>--disable-content-trust</code>: 跳过镜像内容的校验，默认为 true;</li></ol></li></ul><h1 id="四、DockerFile"><a href="#四、DockerFile" class="headerlink" title="四、DockerFile"></a>四、DockerFile</h1><ul><li><p>4.1 什么是dockerfile?</p><p>dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p></li><li><p>4.2 FROM 和 RUN 指令的作用</p><p><strong>FROM</strong>：定制的镜像都是基于 FROM 的镜像，这里的 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx。</p><p><strong>RUN</strong>：用于执行后面跟着的命令行命令。有以下俩种格式：</p><p>shell 格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN &lt;命令行命令&gt;</span><br></pre></td></tr></table></figure><p>exec 格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</span><br></pre></td></tr></table></figure><p>ADD：将本地文件添加到容器中，tar类型文件会自动解压(网络压缩资源不会被解压)，可以访问网络资源，类似wget</p><p>COPY：功能类似ADD，但是是不会自动解压文件，也不能访问网络资源</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alipay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python enumerate() 函数、With关键字</title>
      <link href="/2019/07/20/a_id_4/"/>
      <url>/2019/07/20/a_id_4/</url>
      
        <content type="html"><![CDATA[<h4 id="Python-enumerate-函数"><a href="#Python-enumerate-函数" class="headerlink" title="Python enumerate() 函数"></a>Python enumerate() 函数</h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>enumerate()也是一个python的一个内置方法，用于将一个可遍历的对象（比如说列表，元组和字符串）组合成一个索引序列，同时还可以列出数据下标，和数据<br>2.6版本添加start参数</p><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><blockquote><blockquote><p>seasons = [‘猪猪侠’, ‘小胖’, ‘徐必成’]<br>list(enumerate(li))<br>[(0, ‘猪猪侠’), (1, ‘小胖’), (2, ‘徐必成’)]</p></blockquote></blockquote><blockquote><p> list(enumerate(li,start=1))  start: 下标从1开始<br>[(1, ‘猪猪侠’), (2, ‘小胖’), (3, ‘徐必成’)]</p></blockquote><h3 id="with关键字作用"><a href="#with关键字作用" class="headerlink" title="with关键字作用"></a>with关键字作用</h3><blockquote><p>使用with后不管with中的代码出现什么错误，都会进行对当前对象进行清理工作。</p><p>例如file的file.close()方法，无论with中出现任何错误，都会执行file.close（）方法</p></blockquote><blockquote><p>举个例子：比如说写文件，先打开文件，再写入，然后关闭，比较繁琐。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f &#x3D; open(&#39;1.txt&#39;, &#39;a&#39;)  # 打开文件</span><br><span class="line">f.write(&#39;hello&#39;)# 写入文件</span><br><span class="line">f.close()# 关闭文件</span><br></pre></td></tr></table></figure><blockquote><p>使用with关键字是上下文的关键字，将使用的with的对象交给python上下文管理器，</p></blockquote><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">with opne(&#x27;1.txt&#x27;, &#x27;a&#x27;) as f:</span></span><br><span class="line"><span class="xml">f.Write(’hello&#x27;)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alipay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Httpx自动化脚本测试</title>
      <link href="/2019/06/13/a_id_3/"/>
      <url>/2019/06/13/a_id_3/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import httpx</span><br><span class="line"></span><br><span class="line"># 测试url地址</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;&#39;</span><br><span class="line"></span><br><span class="line"># 测试提供的参数</span><br><span class="line">data &#x3D; &#123;&#39;username&#39;: &#39;username&#39;, &#39;pwd&#39;: pwd&#125;</span><br><span class="line"></span><br><span class="line"># 增加用户</span><br><span class="line"></span><br><span class="line">httpx.post(url, data&#x3D;data)</span><br><span class="line"></span><br><span class="line"># 删除用户</span><br><span class="line"></span><br><span class="line">httpx.delete(url, params&#x3D;&#123;&#39;id&#39;: id&#125;)</span><br><span class="line"></span><br><span class="line"># 修改用户</span><br><span class="line"></span><br><span class="line">httpx.update(url, data&#x3D;data, params&#x3D;&#123;&#39;id&#39;: id&#125;)</span><br><span class="line"></span><br><span class="line"># 展示用户</span><br><span class="line"></span><br><span class="line">httpx.get(url)</span><br></pre></td></tr></table></figure><blockquote><p>以上就是手动测试代码,仅供参考!</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alipay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2019/03/29/a_id_2/"/>
      <url>/2019/03/29/a_id_2/</url>
      
        <content type="html"><![CDATA[<h1 id="今天主要来说一下工厂模式和单例模式"><a href="#今天主要来说一下工厂模式和单例模式" class="headerlink" title="今天主要来说一下工厂模式和单例模式!"></a>今天主要来说一下工厂模式和单例模式!</h1><h3 id="首先说下工厂模式"><a href="#首先说下工厂模式" class="headerlink" title="首先说下工厂模式"></a>首先说下工厂模式</h3><p style="font-size:15px">然后举个例子吧: 比亚迪汽车公司都知道吧，生产汽车的，但是在疫情期间它也是生产口罩的，我们不关心它比亚迪里面是干啥的，我只关心它生产出来的产品是什么，工厂模式模式可以帮助我们解耦，关于解耦这个词就是说我不参与工厂内部所有逻辑，我只需要告诉工厂(换句话说传参数)我需要什么。</p><br><p style="font-size:18px">那么工程模式在项目中主要涉及到哪里呢？</p><p style="font-size:15px">    像项目中的三方登录（微信，钉钉，qq等）可以使用工厂模式使用，使用的好处也就是可以帮助我们解耦！</p><br><br><h3 id="然后说单例模式"><a href="#然后说单例模式" class="headerlink" title="然后说单例模式"></a>然后说单例模式</h3><p>比如说在调用类对象时，内存地址的区别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ABC(object):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(id(A))</span><br><span class="line">print(id(B))</span><br><span class="line"></span><br><span class="line">47439632</span><br><span class="line">47439600</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后它的实例内存地址也是不一样的</p><p style="font-size:15px">举个例子: 我们每次调用一个支付类，你调用一次二次没关系，如果是成千上万个用户同时在这一刻在调用呢?你的内存直接回爆掉，因为内存地址不一致，它每次调用都会重新调用一份内存地址，所以说这块需要我们使用一个设计模式，也就是单例模式</p><p style="font-size:15px">单例模式简介:    就是我每次实例化对象，这个对象我不做销毁，这个对象就存在内存中，等下次再有人来实例化直接使用内存中的实例，节约了实例化的的过程，也节约掉了实例化空间，单例模式带给我们的是性能上的提升.</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p style="font-size:15px">       　　 工厂模式带给我们的是业务上的解耦 <br>       　 　单例模式带给我们的是性能上的提升</p>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alipay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频直播</title>
      <link href="/2019/03/12/a_id_1/"/>
      <url>/2019/03/12/a_id_1/</url>
      
        <content type="html"><![CDATA[<h3 id="一、首先如何实现直播"><a href="#一、首先如何实现直播" class="headerlink" title="一、首先如何实现直播"></a>一、首先如何实现直播</h3><ul><li>需要打开OBS，设置推流地址和密钥</li></ul><!-- ![](6.1.jpg) --><ul><li>这样用户打开浏览器会对应直播地址</li><li></li></ul><h3 id="二、HTTP-FLV环境部署"><a href="#二、HTTP-FLV环境部署" class="headerlink" title="二、HTTP-FLV环境部署"></a>二、HTTP-FLV环境部署</h3><ul><li><p>创建保存软件文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;home</span><br><span class="line">mkdir Environment</span><br></pre></td></tr></table></figure></li><li><p> 下载nginx</p><ul><li>   nginx可以使你支持多个用户同时连接</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.18.0.tar.gz </span><br></pre></td></tr></table></figure></li><li><p> 下载直播模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;winshining&#x2F;nginx-http-flv-module</span><br></pre></td></tr></table></figure></li><li><p> 解压nginx和rtmp模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nginx-1.18.0.tar.gz </span><br><span class="line"></span><br><span class="line">unzip nginx-http-flv-module</span><br></pre></td></tr></table></figure></li><li><p> 创建nginx的安装目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;nginx-rtmp</span><br></pre></td></tr></table></figure></li><li><p> 进入解压好的nginx目录,进行配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd nginx-1.18.0</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx-flv --add-module&#x3D;&#x2F;home&#x2F;flv-tools&#x2F;nginx-http-flv-module</span><br><span class="line">#--prefix: 安装路径</span><br><span class="line">#--add-module: 装插件</span><br></pre></td></tr></table></figure></li><li><p> 编译安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install </span><br></pre></td></tr></table></figure></li><li><p> 配置文件修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;nginx-flv&#x2F;conf</span><br></pre></td></tr></table></figure><p>进入目录找到nginx.conf</p><p>vim修改</p></li></ul><ul><li><p>配置文件部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">rtmp_auto_push on;</span><br><span class="line">rtmp_auto_push_reconnect 1s;</span><br><span class="line">rtmp_socket_dir &#x2F;tmp;</span><br><span class="line"></span><br><span class="line">rtmp&#123;</span><br><span class="line">out_queue 4096;</span><br><span class="line">out_cork 8;</span><br><span class="line">max_streams 128;</span><br><span class="line">timeout 15s;</span><br><span class="line">drop_idle_publisher 15s;</span><br><span class="line">log_interval 5s;</span><br><span class="line">log_size 1m;</span><br><span class="line">server &#123;</span><br><span class="line">listen 1935; # 推流端口</span><br><span class="line">server_name zege;</span><br><span class="line"></span><br><span class="line">application live &#123;# 配置推流地址</span><br><span class="line">live on; # 打开推流</span><br><span class="line"># gop_cache on;</span><br><span class="line"># rtmp:&#x2F;&#x2F;123.123.123.123:1935&#x2F;live&#x2F;test</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>配置文件http拉流部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">include       mime.types;</span><br><span class="line">default_type  application&#x2F;octet-stream;</span><br><span class="line">sendfile        on;</span><br><span class="line">keepalive_timeout  65;</span><br><span class="line">server &#123;</span><br><span class="line">listen       8080; # 拉流通过8080去拉流</span><br><span class="line"># http:&#x2F;&#x2F;123.123.123.123:8080&#x2F;live&#x2F;?port&#x3D;1935&amp;stream&#x3D;test</span><br><span class="line">server_name  localhost;</span><br><span class="line">location &#x2F;live &#123;</span><br><span class="line">flv_live on;</span><br><span class="line">chunked_transfer_encoding  on;</span><br><span class="line">add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;;</span><br><span class="line">add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>最后开启服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;nginx-flv&#x2F;sbin&#x2F;nginx -c &#x2F;usr&#x2F;local&#x2F;nginx-flv&#x2F;conf&#x2F;nginx.conf</span><br></pre></td></tr></table></figure><h3 id="三、Vue实现拉流"><a href="#三、Vue实现拉流" class="headerlink" title="三、Vue实现拉流"></a>三、Vue实现拉流</h3><ul><li><p>安装<strong>flv.js</strong>开源工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install flv.js --save</span><br></pre></td></tr></table></figure></li></ul></li><li><p>导入</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import flv from &#39;flv.js&#39;</span><br></pre></td></tr></table></figure></li><li><p>构建页面标签</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;video id&#x3D;&quot;videoElement&quot; controls muted&gt;</span><br><span class="line">pass</span><br><span class="line">&lt;&#x2F;video&gt;</span><br></pre></td></tr></table></figure></li><li><p>初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> mounted() &#123;</span><br><span class="line">    var videoElement &#x3D; document.getElementById(&#39;videoElement&#39;);</span><br><span class="line">    var flvPlayer &#x3D; flv.createPlayer(&#123;</span><br><span class="line">      type: &#39;flv&#39;,</span><br><span class="line">      enableWorker: true,     &#x2F;&#x2F;浏览器端开启flv.js的worker,多进程运行flv.js</span><br><span class="line">      isLive: true,           &#x2F;&#x2F;直播模式</span><br><span class="line">      hasAudio: false,        &#x2F;&#x2F;关闭音频</span><br><span class="line">      hasVideo: true,</span><br><span class="line">      &#x2F;&#x2F; cors: true,</span><br><span class="line">      stashInitialSize: 128,</span><br><span class="line">      enableStashBuffer: false, &#x2F;&#x2F;播放flv时，设置是否启用播放缓存，只在直播起作用。</span><br><span class="line">      url: &#39;http:&#x2F;&#x2F;47.93.48.154:8080&#x2F;live?port&#x3D;1935&amp;app&#x3D;live&amp;stream&#x3D;test&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">    flvPlayer.attachMediaElement(videoElement);</span><br><span class="line">    flvPlayer.load();</span><br><span class="line">    flvPlayer.play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="四、最终在浏览器实现直播效果"><a href="#四、最终在浏览器实现直播效果" class="headerlink" title="四、最终在浏览器实现直播效果"></a>四、最终在浏览器实现直播效果</h3><!-- ![](6.2.jpg) -->]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alipay </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
