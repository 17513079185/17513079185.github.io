<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>志杰的技术博客</title>
  
  <subtitle>Django/Vue学习</subtitle>
  <link href="http://v3n.top/atom.xml" rel="self"/>
  
  <link href="http://v3n.top/"/>
  <updated>2022-05-07T08:55:13.758Z</updated>
  <id>http://v3n.top/</id>
  
  <author>
    <name>志杰</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Conda搭建python环境</title>
    <link href="http://v3n.top/2022/01/15/a_id_27/"/>
    <id>http://v3n.top/2022/01/15/a_id_27/</id>
    <published>2022-01-14T16:00:00.000Z</published>
    <updated>2022-05-07T08:55:13.758Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Conda使用指南"><a href="#Conda使用指南" class="headerlink" title="Conda使用指南"></a>Conda使用指南</h1><p>我们在使用python语言的时候，有时可能会为了环境问题而烦恼，并且python的版本也是很多，相关库的依赖性很强，在库的安装和版本的管理会有很大的麻烦，Conda说白了就是一个管理版本和python环境的一套工具，使用起来非常的方便</p><p>首先你也得先进入<a href>conda</a>官网，选择对应的版本进行下载安装</p><h2 id="下载之后说一下Conda的环境管理"><a href="#下载之后说一下Conda的环境管理" class="headerlink" title="下载之后说一下Conda的环境管理"></a>下载之后说一下Conda的环境管理</h2><h3 id="创建环境"><a href="#创建环境" class="headerlink" title="创建环境"></a>创建环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 第一种指定版本 创建一个名称为 python_3.8环境， 指定版本也是python3.8版本</span><br><span class="line">conda create --name pyhon_3.8 python&#x3D;3.8</span><br><span class="line"># 第二种指定配置文件环境  environment.yml（配置文件）</span><br><span class="line">conda env create -f environment.yml</span><br></pre></td></tr></table></figure><h3 id="查看环境"><a href="#查看环境" class="headerlink" title="查看环境"></a>查看环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有环境</span><br><span class="line">conda info --env 或者 conda env list</span><br></pre></td></tr></table></figure><h3 id="切换环境"><a href="#切换环境" class="headerlink" title="切换环境"></a>切换环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 切换环境</span><br><span class="line">conda activate 环境名</span><br></pre></td></tr></table></figure><h3 id="删除环境"><a href="#删除环境" class="headerlink" title="删除环境"></a>删除环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 删除指定环境</span><br><span class="line">conda remove -n 虚拟环境名称</span><br></pre></td></tr></table></figure><h3 id="解决在指定环境中-pip-install下载速度慢问题"><a href="#解决在指定环境中-pip-install下载速度慢问题" class="headerlink" title="解决在指定环境中 pip install下载速度慢问题"></a>解决在指定环境中 pip install下载速度慢问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#显示目前conda的数据源有哪些</span><br><span class="line">conda config --show channels</span><br><span class="line">#添加数据源：例如, 添加清华anaconda镜像：</span><br><span class="line">conda config --add channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;free&#x2F;</span><br><span class="line">conda config --add channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;main&#x2F;</span><br><span class="line">conda config --set show_channel_urls yes</span><br><span class="line">#删除数据源</span><br><span class="line">conda config --remove channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;free&#x2F;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Conda使用指南&quot;&gt;&lt;a href=&quot;#Conda使用指南&quot; class=&quot;headerlink&quot; title=&quot;Conda使用指南&quot;&gt;&lt;/a&gt;Conda使用指南&lt;/h1&gt;&lt;p&gt;我们在使用python语言的时候，有时可能会为了环境问题而烦恼，并且python的版</summary>
      
    
    
    
    <category term="个人总结" scheme="http://v3n.top/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="alipay" scheme="http://v3n.top/tags/alipay/"/>
    
  </entry>
  
  <entry>
    <title>使用Python模仿PC端微信恢复</title>
    <link href="http://v3n.top/2021/10/22/a_id_26/"/>
    <id>http://v3n.top/2021/10/22/a_id_26/</id>
    <published>2021-10-21T16:00:00.000Z</published>
    <updated>2021-10-22T11:33:35.324Z</updated>
    
    <content type="html"><![CDATA[<p style="font-size:17px">本篇呢主要是利用这个python的两个依赖库(PyAutoGUI和pyperclip)来进行微信自动恢复消息</p><br><p style="font-size:21px">介绍下这两个依赖库</p><p style="font-size:17px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PyAutoGUI是一个纯Python的GUI自动化工具，其目的是可以用程序自动控制鼠标和键盘操作，利用它可以实现自动化任务，再也不用担心有重复枯燥的任务了。</p><p style="font-size:17px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PyPeRCLIP模块中有两个函数，分别是copy ()和paste ()，copy ()用于向计算机的剪贴板发送文本，paste ()用于从计算机剪贴板接收文本</p><h4 id="介绍完后直接安装下依赖库"><a href="#介绍完后直接安装下依赖库" class="headerlink" title="介绍完后直接安装下依赖库"></a>介绍完后直接安装下依赖库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install pyautogui -i http:&#x2F;&#x2F;pypi.douban.com&#x2F;simple&#x2F; --trusted-host pypi.douban.com</span><br><span class="line">pip3 install pyperclip -i http:&#x2F;&#x2F;pypi.douban.com&#x2F;simple&#x2F; --trusted-host pypi.douban.com</span><br></pre></td></tr></table></figure><h4 id="安装后进入代码"><a href="#安装后进入代码" class="headerlink" title="安装后进入代码"></a>安装后进入代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"># 导入依赖及需要的包</span><br><span class="line">import pyautogui  </span><br><span class="line">import pyperclip</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def get_msg():</span><br><span class="line">   &quot;&quot;&quot;想发的消息，每条消息空格分开&quot;&quot;&quot;</span><br><span class="line">   contents &#x3D; &quot;您好&quot;</span><br><span class="line">   return contents.split(&quot; &quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def send(msg):</span><br><span class="line">    # 复制需要发送的内容到粘贴板</span><br><span class="line">    pyperclip.copy(msg)</span><br><span class="line">    # 模拟键盘 ctrl + v 粘贴内容</span><br><span class="line">    pyautogui.hotkey(&#39;ctrl&#39;, &#39;v&#39;)</span><br><span class="line">    # 发送消息</span><br><span class="line">    pyautogui.press(&#39;enter&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def send_msg(friend):</span><br><span class="line">    # Ctrl + alt + w  模仿控制快捷键</span><br><span class="line">    pyautogui.hotkey(&#39;ctrl&#39;, &#39;alt&#39;, &#39;w&#39;)</span><br><span class="line">    # 搜索好友</span><br><span class="line">    pyautogui.hotkey(&#39;ctrl&#39;, &#39;f&#39;)</span><br><span class="line">    # 复制好友昵称到粘贴板</span><br><span class="line">    pyperclip.copy(friend)</span><br><span class="line">    # 模拟键盘 ctrl + v 粘贴</span><br><span class="line">    pyautogui.hotkey(&#39;ctrl&#39;, &#39;v&#39;)</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    # 回车进入好友消息界面</span><br><span class="line">    pyautogui.press(&#39;enter&#39;)</span><br><span class="line">    # 一条一条发送消息</span><br><span class="line">    for msg in get_msg():</span><br><span class="line"></span><br><span class="line">        send(msg)</span><br><span class="line">        # 每条消息间隔 2 秒</span><br><span class="line">        time.sleep(2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    friend_name &#x3D; &quot;黄总&quot;</span><br><span class="line">    send_msg(friend_name)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p style=&quot;font-size:17px&quot;&gt;
本篇呢主要是利用这个python的两个依赖库(PyAutoGUI和pyperclip)来进行微信自动恢复消息
&lt;/p&gt;

&lt;br&gt;
&lt;p style=&quot;font-size:21px&quot;&gt;
介绍下这两个依赖库
&lt;/p&gt;

&lt;p s</summary>
      
    
    
    
    <category term="个人总结" scheme="http://v3n.top/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="alipay" scheme="http://v3n.top/tags/alipay/"/>
    
  </entry>
  
  <entry>
    <title>双系统Mongo备份与恢复问题(压缩包格式)</title>
    <link href="http://v3n.top/2021/10/13/a_id_25/"/>
    <id>http://v3n.top/2021/10/13/a_id_25/</id>
    <published>2021-10-12T16:00:00.000Z</published>
    <updated>2021-10-22T11:42:13.945Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、关于Mongo的mongodump的备份"><a href="#一、关于Mongo的mongodump的备份" class="headerlink" title="一、关于Mongo的mongodump的备份"></a>一、关于Mongo的mongodump的备份</h3><br><p style="font-size:17px">首先介绍下一些参数问题</p><p style="font-size:17px">-h： MongDB所在服务器地址，例如：127.0.0.1，当然也可以指定端口号：127.0.0.1:27017</p><p style="font-size:17px">-d： </p><p style="font-size:17px">需要备份的数据库实例，例如：test</p><p style="font-size:17px">-o： 备份的数据存放位置，例如：d:\data\dump，当然该目录需要提前建立，在备份完成后，系统自动在dump目录下建立一个test目录，这个目录里面存放该数据库实例的备份数据。</p><p style="font-size:17px">--archive： 打包好的文件保存地址<br><br></p><p style="font-size:23px">使用mongodump命令来进行打包</p><p style="font-size:17px">mongodump -h 127.0.0.1 --port 27017 -d work -c worek --authenticationDatabase=admin  --gzip --archive=C:\Users\desktop\es.tar.gz出现这个代表备份成功啦, 2条数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">021-10-18T17:40:16.548+0800    writing work.work to archive &#39;C:\Users\desktop\es.tar.gz&#39;</span><br><span class="line">2021-10-18T17:40:16.570+0800    done dumping work.work (2 documents)</span><br></pre></td></tr></table></figure><br></p><h3 id="二、恢复mongorestore"><a href="#二、恢复mongorestore" class="headerlink" title="二、恢复mongorestore"></a>二、恢复mongorestore</h3><p style="font-size:17px">当然有备份, 就有恢复, 恢复数据的话可以分成2种方式, 第一种原表恢复, 另一种就是重命名空间恢复<ul><li><p style="font-size:17px">第一种</p></li></ul></p><p style="font-size:17px">首先来说一下原表恢复, 也就是说我刚才从work数据库中的work表中备份的,测试的时候可以把原来表中数据删除,方便看效果.</p><p style="font-size:17px">--nsInclude 这个参数表示你备份时原来的库名.表名 (例如work.work)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongorestore -h 127.0.0.1 --port&#x3D;27017 --nsInclude&#x3D;work.work --gzip --archive&#x3D;C:\Users\desktop\es.tar.gz</span><br></pre></td></tr></table></figure></p><p style="font-size:17px">出现这种就是数据已经恢复了, 这个时候可以去库查看一下, 已经恢复好了, 也是成功恢复了2条数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2021-10-18T17:50:42.409+0800    preparing collections to restore from</span><br><span class="line">2021-10-18T17:50:42.437+0800    reading metadata for work.work from archive &#39;C:\Users\desktop\es.tar.gz&#39;</span><br><span class="line">2021-10-18T17:50:42.438+0800    restoring work.work from archive &#39;C:\Users\desktop\es.tar.gz&#39;</span><br><span class="line">2021-10-18T17:50:42.439+0800    error: multiple errors in bulk operation:</span><br><span class="line">  - E11000 duplicate key error collection: work.work index: _id_ dup key: &#123; : ObjectId(&#39;60514fd1703c9b2e2964738b&#39;) &#125;</span><br><span class="line">  - E11000 duplicate key error collection: work.work index: _id_ dup key: &#123; : ObjectId(&#39;605151b8703c9b2e2964738c&#39;) &#125;</span><br><span class="line"></span><br><span class="line">2021-10-18T17:50:42.439+0800    no indexes to restore</span><br><span class="line">2021-10-18T17:50:42.440+0800    finished restoring work.work (2 documents)</span><br><span class="line">2021-10-18T17:50:42.441+0800    done</span><br></pre></td></tr></table></figure><br><ul><li><p style="font-size:17px">第二种</p></li></ul></p><p style="font-size:17px">来说一下重新命名方法</p><p style="font-size:17px">我们这次将恢复到work数据库下的work2表中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongorestore -h 127.0.0.1 --port&#x3D;27017  --nsFrom work.work  --nsTo work.work2 --gzip --archive&#x3D;C:\Users\Desktop\es.tar.gz </span><br></pre></td></tr></table></figure></p><p style="font-size:17px">大功告成<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2021-10-18T17:56:35.257+0800    preparing collections to restore from</span><br><span class="line">2021-10-18T17:56:35.283+0800    reading metadata for work.work2 from archive &#39;C:\Users\Desktop\es.tar.gz&#39;</span><br><span class="line">2021-10-18T17:56:35.290+0800    restoring work.work2 from archive &#39;C:\Users\Desktop\es.tar.gz&#39;</span><br><span class="line">2021-10-18T17:56:35.291+0800    no indexes to restore</span><br><span class="line">2021-10-18T17:56:35.291+0800    finished restoring work.work2 (2 documents)</span><br><span class="line">2021-10-18T17:56:35.296+0800    done</span><br></pre></td></tr></table></figure><br></p><p style="font-size:17px">注意的是 --nsFrom work.work --nsTo work.work2 --nsFrom 这个是你原来的备份的位置, --nsTo这个是你要重新命名的位置</p><p style="font-size:17px">更多参数可查看官方文档</p><p><a href="https://www.mongodb.com/zh-cn">https://www.mongodb.com/zh-cn</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、关于Mongo的mongodump的备份&quot;&gt;&lt;a href=&quot;#一、关于Mongo的mongodump的备份&quot; class=&quot;headerlink&quot; title=&quot;一、关于Mongo的mongodump的备份&quot;&gt;&lt;/a&gt;一、关于Mongo的mongodump的</summary>
      
    
    
    
    <category term="个人总结" scheme="http://v3n.top/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="alipay" scheme="http://v3n.top/tags/alipay/"/>
    
  </entry>
  
  <entry>
    <title>Linux下设置容器中Redis密码</title>
    <link href="http://v3n.top/2021/09/29/a_id_24/"/>
    <id>http://v3n.top/2021/09/29/a_id_24/</id>
    <published>2021-09-28T16:00:00.000Z</published>
    <updated>2021-10-13T10:59:19.422Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-首先拉取Redis镜像过来"><a href="#1-首先拉取Redis镜像过来" class="headerlink" title="1.首先拉取Redis镜像过来"></a>1.首先拉取Redis镜像过来</h3><p>这里可以去指定版本进行拉取不同的版本 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis </span><br></pre></td></tr></table></figure><h3 id="2-这里可以查看一下镜像"><a href="#2-这里可以查看一下镜像" class="headerlink" title="2.这里可以查看一下镜像"></a>2.这里可以查看一下镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><h3 id="3-确定镜像存在后通过镜像启动容器"><a href="#3-确定镜像存在后通过镜像启动容器" class="headerlink" title="3.确定镜像存在后通过镜像启动容器"></a>3.确定镜像存在后通过镜像启动容器</h3><p>设置密码只需要加–requirepass “yourpassword”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 6379:6379 --name redis --requirepass &quot;yourpassword&quot;</span><br></pre></td></tr></table></figure><h3 id="4-然后可以进入容器进行验证"><a href="#4-然后可以进入容器进行验证" class="headerlink" title="4.然后可以进入容器进行验证"></a>4.然后可以进入容器进行验证</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 容器名或id &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>redis-cli 进入</p><p>注意 只有在你输入命令时才会触发密码</p><p>127.0.0.1:6379&gt; get *<br>(error) NOAUTH Authentication required.</p><h3 id="5-进行验证密码"><a href="#5-进行验证密码" class="headerlink" title="5.进行验证密码"></a>5.进行验证密码</h3><p>输入完显示OK就表示验证成功啦</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth password</span><br></pre></td></tr></table></figure><p>127.0.0.1:6379&gt; auth [设置的密码]<br>OK</p><h3 id="这样的话就大功告成啦"><a href="#这样的话就大功告成啦" class="headerlink" title="这样的话就大功告成啦"></a>这样的话就大功告成啦</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-首先拉取Redis镜像过来&quot;&gt;&lt;a href=&quot;#1-首先拉取Redis镜像过来&quot; class=&quot;headerlink&quot; title=&quot;1.首先拉取Redis镜像过来&quot;&gt;&lt;/a&gt;1.首先拉取Redis镜像过来&lt;/h3&gt;&lt;p&gt;这里可以去指定版本进行拉取不同的版本</summary>
      
    
    
    
    <category term="个人总结" scheme="http://v3n.top/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="alipay" scheme="http://v3n.top/tags/alipay/"/>
    
  </entry>
  
  <entry>
    <title>基于ApiDoc快速制作文档</title>
    <link href="http://v3n.top/2021/09/27/a_id_23/"/>
    <id>http://v3n.top/2021/09/27/a_id_23/</id>
    <published>2021-09-26T16:00:00.000Z</published>
    <updated>2021-10-09T06:03:48.097Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ApiDoc文档自动化生成工具"><a href="#ApiDoc文档自动化生成工具" class="headerlink" title="ApiDoc文档自动化生成工具"></a>ApiDoc文档自动化生成工具</h1><h2 id="首先来介绍下ApiDoc文档自动化生成工具-apidoc是一个轻量级的在线REST接口文档生成系统，支持多种主流语言，包括Java、C、C-、PHP和Javascript等都是支持的。"><a href="#首先来介绍下ApiDoc文档自动化生成工具-apidoc是一个轻量级的在线REST接口文档生成系统，支持多种主流语言，包括Java、C、C-、PHP和Javascript等都是支持的。" class="headerlink" title="首先来介绍下ApiDoc文档自动化生成工具,apidoc是一个轻量级的在线REST接口文档生成系统，支持多种主流语言，包括Java、C、C#、PHP和Javascript等都是支持的。"></a>首先来介绍下ApiDoc文档自动化生成工具,apidoc是一个轻量级的在线REST接口文档生成系统，支持多种主流语言，包括Java、C、C#、PHP和Javascript等都是支持的。</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><p style="font-size:17px">    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apidoc是基于nodeJs平台，在安装apidoc之前，需要先安装nodeJs。关于nodeJs的安装，一搜一大把，不过为了文章的完整性，还是首先介绍一下Windows平台下nodeJs的安装。</p><br><ul><li>进入windows的cmd 输入以下命令安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install apidoc -g</span><br></pre></td></tr></table></figure><h3 id="2-操作"><a href="#2-操作" class="headerlink" title="2.操作"></a>2.操作</h3></li><li>在使用之前需要生成接口文档的目录下新建一个apidoc.json<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;   </span><br><span class="line">  &quot;name&quot;: &quot;example&quot;,   # 文档名字</span><br><span class="line">  &quot;version&quot;: &quot;0.1.0&quot;,  # 版本号</span><br><span class="line">  &quot;description&quot;: &quot;example&quot;,  # 详细介绍  </span><br><span class="line">  &quot;title&quot;: &quot;title&quot;,   # 文档标题</span><br><span class="line">  &quot;url&quot; : &quot;http:&#x2F;&#x2F;www.test.com&quot;  # api url的前缀</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>新建一个python文件：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @api &#123;post&#125; &#x2F;user 中文</span><br><span class="line"> * @apiName obj</span><br><span class="line"> * @apiParam &#123;Object&#125; person </span><br><span class="line"> * @apiParam &#123;String&#125; person.name  姓名 </span><br><span class="line"> * @apiParam &#123;Integer&#125; person.age 年龄 </span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure></li><li>直接使用apidoc命令生成文档<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apidoc</span><br></pre></td></tr></table></figure></li><li>apidoc参数说明：</li></ul><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-i</td><td align="center">选择源代码所在位置</td></tr><tr><td align="center">-o</td><td align="center">选择目标生成所在的位置</td></tr></tbody></table><p>更多参数可参考官方文档    <a href="https://apidocjs.com/">https://apidocjs.com/</a></p><ul><li>常用的一些命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apidoc -c path&#x2F;to&#x2F;apidoc.json</span><br></pre></td></tr></table></figure></li><li>以下就是生成后的模板</li></ul><p><img src="/.top//09/27/a_id_23/wc.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ApiDoc文档自动化生成工具&quot;&gt;&lt;a href=&quot;#ApiDoc文档自动化生成工具&quot; class=&quot;headerlink&quot; title=&quot;ApiDoc文档自动化生成工具&quot;&gt;&lt;/a&gt;ApiDoc文档自动化生成工具&lt;/h1&gt;&lt;h2 id=&quot;首先来介绍下ApiDoc文</summary>
      
    
    
    
    <category term="个人总结" scheme="http://v3n.top/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="alipay" scheme="http://v3n.top/tags/alipay/"/>
    
  </entry>
  
  <entry>
    <title>关于FastApi全局校验Token</title>
    <link href="http://v3n.top/2021/09/02/a_id_22/"/>
    <id>http://v3n.top/2021/09/02/a_id_22/</id>
    <published>2021-09-01T16:00:00.000Z</published>
    <updated>2021-09-02T07:51:50.764Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Token介绍"><a href="#Token介绍" class="headerlink" title="Token介绍"></a>Token介绍</h1>  <p style="font-size:23px">  为什么使用Token验证：</p><p>  在Web领域基于Token的身份验证随处可见。在大多数使用Web API的互联网公司中，tokens 是多用户下处理认证的最佳方式。</p><p>  以下几点特性会让你在程序中使用基于Token的身份验证</p><p>  1.无状态、可扩展</p><p>  2.支持移动设备</p><p>  3.跨程序调用</p><p>  4.安全</p><p>  那些使用基于Token的身份验证的大佬们</p><p>  大部分你见到过的API和Web应用都使用tokens。例如Facebook, Twitter, Google+, GitHub等。</p><p></p>其实关于FastAPI添加校验很简单,只需要添加一个中间件即可, 如下:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@app.middleware(&quot;http&quot;)</span><br><span class="line">async def add_process_time_header(request: Request, call_next):</span><br><span class="line">  response &#x3D; await call_next(request)</span><br><span class="line"></span><br><span class="line">  login_url &#x3D; str(request.url)[22:]</span><br><span class="line">  register_url &#x3D; str(request.url)[22:]</span><br><span class="line"></span><br><span class="line">  if login_url &#x3D;&#x3D; &#39;login_user&#39; or register_url &#x3D;&#x3D; &#39;register_user&#39;:  # 屏蔽注册、登录接口, 避免死循环</span><br><span class="line">      return response</span><br><span class="line"></span><br><span class="line">  try:</span><br><span class="line">      token &#x3D; request.headers[&#39;token&#39;]  # 获取前端传过来token</span><br><span class="line">      # jwt.decode(token, key&#x3D;SECRET_KEY)</span><br><span class="line"></span><br><span class="line">  except Exception as e:</span><br><span class="line">      logger.warning(e)</span><br><span class="line">      return JSONResponse(&#123;&#39;msg&#39;: &#39;token验证失败,请重新登陆!&#39;, &#39;code&#39;: 301&#125;)</span><br><span class="line"></span><br><span class="line">  return response</span><br></pre></td></tr></table></figure>### 注意问题    在你添加中间件的时候,要想到它是一个全局的校验,也就是说,当你登录接口和注册接口来访问时如何应对,这个时候你可以把登录&注册接口屏蔽掉,避免死循环.    FastAPI启动方式: uvicorn.run(app='main:app', host="127.0.0.1", port=8008, reload=True, debug=True)]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Token介绍&quot;&gt;&lt;a href=&quot;#Token介绍&quot; class=&quot;headerlink&quot; title=&quot;Token介绍&quot;&gt;&lt;/a&gt;Token介绍&lt;/h1&gt;  &lt;p style=&quot;font-size:23px&quot;&gt;
  为什么使用Token验证：

&lt;/p&gt;&lt;p&gt;</summary>
      
    
    
    
    <category term="个人总结" scheme="http://v3n.top/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="alipay" scheme="http://v3n.top/tags/alipay/"/>
    
  </entry>
  
  <entry>
    <title>Home Brew常用命令总结</title>
    <link href="http://v3n.top/2021/06/05/a_id_21/"/>
    <id>http://v3n.top/2021/06/05/a_id_21/</id>
    <published>2021-06-04T16:00:00.000Z</published>
    <updated>2021-09-02T07:42:11.739Z</updated>
    
    <content type="html"><![CDATA[<br><h1 id="Homebrew是什么？"><a href="#Homebrew是什么？" class="headerlink" title="Homebrew是什么？"></a>Homebrew是什么？</h1><p style="font-size:23px">    然后运行镜像脚本：    Homebrew是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2>   <p style="font-size:23p">     安装XCode或者Command Line Tools for Xcode。Xcode可以从AppStore里下载安装，Command Line Tools for Xcode需要在终端中输入以下代码运行安装：   </p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>   <p style="font-size:23p">     安装Homebrew。将以下命令粘贴至终端   </p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install)&quot;</span><br></pre></td></tr></table></figure><blockquote><p>安装完成以后，需要运行<code>brew doctor</code>命令检测下是否有什么冲突的地方（如没有卸载<code>MacPorts</code>等等）</p><p><code>Homebrew</code>安装成功后，会自动创建目录<code>/usr/local/Cellar</code>来存放<code>Homebrew</code>安装的程序。</p></blockquote>   <p style="font-size:23p">     安装Homebrew。将以下命令粘贴至终端   </p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;uninstall)&quot;</span><br></pre></td></tr></table></figure><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 搜索包</span></span><br><span class="line">brew search mysql</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安装包</span></span><br><span class="line">brew install mysql</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看包信息，比如目前的版本，依赖，安装后注意事项等</span></span><br><span class="line">brew info mysql</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载包</span></span><br><span class="line">brew uninstall wget</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示已安装的包</span></span><br><span class="line">brew <span class="built_in">list</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看brew的帮助</span></span><br><span class="line">brew –help</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新， 这会更新 Homebrew 自己</span></span><br><span class="line">brew update</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查过时（是否有新版本），这会列出所有安装的包里，哪些可以升级</span></span><br><span class="line">brew outdated</span><br><span class="line">brew outdated mysql</span><br><span class="line"></span><br><span class="line"><span class="comment">// 升级所有可以升级的软件们</span></span><br><span class="line">brew upgrade</span><br><span class="line">brew upgrade mysql</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理不需要的版本极其安装包缓存</span></span><br><span class="line">brew cleanup</span><br><span class="line">brew cleanup mysql</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre><code>安装软件：brew install 软件名，例：brew install wget</code></pre><p>　　搜索软件：brew search 软件名，例：brew search wget<br>　　卸载软件：brew uninstall 软件名，例：brew uninstall wget<br>　　更新所有软件：brew update<br>　　更新具体软件：brew upgrade 软件名 ，例：brew upgrade git<br>　　显示已安装软件：brew list<br>　　查看软件信息：brew info／home 软件名 ，例：brew info git ／ brew home git<br>　　显示包依赖：brew reps<br>　　显示安装的服务：brew services list<br>　　安装服务启动、停止、重启：brew services start/stop/restart serverName</p>]]></content>
    
    
      
      
    <summary type="html">&lt;br&gt;

&lt;h1 id=&quot;Homebrew是什么？&quot;&gt;&lt;a href=&quot;#Homebrew是什么？&quot; class=&quot;headerlink&quot; title=&quot;Homebrew是什么？&quot;&gt;&lt;/a&gt;Homebrew是什么？&lt;/h1&gt;&lt;p style=&quot;font-size:23px&quot;&gt;
</summary>
      
    
    
    
    <category term="个人总结" scheme="http://v3n.top/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="alipay" scheme="http://v3n.top/tags/alipay/"/>
    
  </entry>
  
  <entry>
    <title>Alpine作为你Docker的Python开发基础镜像？其实Ubuntu更好一点</title>
    <link href="http://v3n.top/2021/05/20/a_id_20/"/>
    <id>http://v3n.top/2021/05/20/a_id_20/</id>
    <published>2021-05-19T16:00:00.000Z</published>
    <updated>2021-07-23T08:07:27.875Z</updated>
    
    <content type="html"><![CDATA[<p style="font-size:23px">当你想为你的Python开发环境选择一个基础镜像时，大多数人都会选择Alpine，为什么？因为它太小了，仅仅只有 5 MB 左右（对比 Ubuntu 系列镜像接近 100 MB），但事实的真相是，我们选择基础镜像并不是为了体验一下Python语法而已，在此基础上，我们需要调试和安装各种扩展，可能会安装很多三方依赖，甚至预设更多服务，在这种环境下，Alpine就并非是一个很好的选择了，本次我们就来分别在Alpine和Ubuntu上来体验一下</p><br><p style="font-size:23px">首先分别拉取Alpine和Ubuntu的镜像：</p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu:18.04</span><br><span class="line">docker pull alpine</span><br></pre></td></tr></table></figure><p style="font-size:23px">拉取完毕后，可以看到，体积上确实差距明显：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY                  TAG                   IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu                      18.04                 6526a1858e5d        2 weeks ago         64.2MB</span><br><span class="line">alpine                      latest                a24bb4013296        3 months ago        5.57MB</span><br></pre></td></tr></table></figure><p style="font-size:23px">ubuntu占用64mb，而alpine仅仅5.57mb。<pre><code>但是先别着急，假设我们的python应用需要做一些科学计算，并且将数据以图形的方式展示出来，这时候就需要matplotlib和pandas这两个库的帮助了，先用ubuntu来安装这俩个库，编写Dockerfile.ubuntu</code></pre></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.7-slim</span><br><span class="line">RUN pip install --no-cache-dir matplotlib pandas</span><br></pre></td></tr></table></figure><p style="font-size:23px"> 然后运行镜像脚本：</p><pre><code>docker build -f Dockerfile.ubuntu -t &#39;ubuntu-mat&#39; .</code></pre><p style="font-size:23px"> 可以看到，编译好的镜像从原先的60mb暴涨到了263mb。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">liuyue:blog liuyue$ docker images</span><br><span class="line">REPOSITORY                  TAG                   IMAGE ID            CREATED              SIZE</span><br><span class="line">ubuntu-mat                  latest                401f0425ce63        About a minute ago   263MB</span><br></pre></td></tr></table></figure><p style="font-size:23px"> 使用起来没有什么问题。<pre><code>现在，我们来试试Alpine，看看速度和体积上有没有比Ubuntu更具优势编写Dockerfile.alpine:</code></pre></p><pre><code>FROM python:3.7-alpineRUN pip install --no-cache-dir matplotlib pandas</code></pre><p style="font-size:23px"> 编译镜像脚本</p><pre><code>docker build -f Dockerfile.alpine -t &#39;alpine-mat&#39; .</code></pre><p style="font-size:23px">     在编译过程中，我们会发现报错了：</p><pre><code>liuyue:blog liuyue$ docker build -f Dockerfile.alpine -t &#39;alpine-mat&#39; .Sending build context to Docker daemon  112.1kBStep 1/2 : FROM python:3.7-alpine3.7-alpine: Pulling from library/pythondf20fa9351a1: Pull complete 36b3adc4ff6f: Pull complete 4db9de03f499: Pull complete cd38a04a61f4: Pull complete 6bbb0c43b470: Pull complete Digest: sha256:d1375bf0b889822c603622dc137b24fb7064e6c1863de8cc4262b61901ce4390Status: Downloaded newer image for python:3.7-alpine---&gt; 078114edb6beStep 2/2 : RUN pip install --no-cache-dir matplotlib pandas---&gt; Running in 6d3c44420e5cCollecting matplotlibDownloading matplotlib-3.3.1.tar.gz (38.8 MB)    ERROR: Command errored out with exit status 1:    command: /usr/local/bin/python -c &#39;import sys, setuptools, tokenize; sys.argv[0] = &#39;&quot;&#39;&quot;&#39;/tmp/pip-install-40p0g06u/matplotlib/setup.py&#39;&quot;&#39;&quot;&#39;; __file__=&#39;&quot;&#39;&quot;&#39;/tmp/pip-install-40p0g06u/matplotlib/setup.py&#39;&quot;&#39;&quot;&#39;;f=getattr(tokenize, &#39;&quot;&#39;&quot;&#39;open&#39;&quot;&#39;&quot;&#39;, open)(__file__);code=f.read().replace(&#39;&quot;&#39;&quot;&#39;\r\n&#39;&quot;&#39;&quot;&#39;, &#39;&quot;&#39;&quot;&#39;\n&#39;&quot;&#39;&quot;&#39;);f.close();exec(compile(code, __file__, &#39;&quot;&#39;&quot;&#39;exec&#39;&quot;&#39;&quot;&#39;))&#39; egg_info --egg-base /tmp/pip-pip-egg-info-zk64hzam        cwd: /tmp/pip-install-40p0g06u/matplotlib/</code></pre><br><p style="font-size:23px">     这是怎么搞的？如果你仔细看上面基于Ubuntu的构建，你会发现它下载三方库的安装包是matplotlib-3.1.2-cp38-cp38-manylinux1_x86_64.whl，这是一个预编译的二进制安装包。而Alpine则只能下载源代码（matplotlib-3.1.2.tar.gz）的压缩包，这就是Alpine的致命问题：标准的Linux安装包在Alpine Linux上根本无法使用。<pre><code>大多数Linux发行版都使用GNU版本的标准C库（glibc），几乎所有基于C语言的脚本语言都需要这个库，包括Python。但Alpine Linux使用的是musl，那些二进制安装包是针对glibc编译的，因此Alpine禁用了Linux安装包支持。现在大多数Python包都在PyPI上包含了二进制安装包，大大加快了安装时间。但是如果你使用的是Alpine Linux，你需要编译你使用的每一个Python包中的所有C源码。这也就意味着你需要自己弄清楚每一个系统库的依赖性。事先编译好需要的依赖，重新改写Dockerfile.alpine:</code></pre></p><pre><code>FROM python:3.7-alpineRUN apk --update add gcc build-base freetype-dev libpng-dev openblas-devRUN pip install --no-cache-dir matplotlib pandas</code></pre><br>    <p style="font-size:23px">     再次编译：    </p><pre><code>docker build -f Dockerfile.alpine -t &#39;alpine-mat&#39; .REPOSITORY                  TAG                   IMAGE ID            CREATED              SIZEalpine-mat                  latest                601f0425ce63        About a minute ago   873MB</code></pre><p style="font-size:23px">     可以看到体积已经变成873mb了，Alpine最引以为傲的体积小轻便等特性也已经荡然无存。<pre><code>虽然从理论上讲，Alpine使用的musl 内核与其他Linux发行版使用的glibc大多是兼容的，但在实际操作中，这种差异可能会造成各种问题。而当这些问题真的发生时，想解决它们就没那么简单了，比如说Alpine的线程默认堆栈容量较小，这会导致Python崩溃，同时也会影响python应用的运行速度。</code></pre></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p style=&quot;font-size:23px&quot;&gt;
当你想为你的Python开发环境选择一个基础镜像时，大多数人都会选择Alpine，为什么？因为它太小了，仅仅只有 5 MB 左右（对比 Ubuntu 系列镜像接近 100 MB），但事实的真相是，我们选择基础镜像并不是为了体验</summary>
      
    
    
    
    <category term="个人总结" scheme="http://v3n.top/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="alipay" scheme="http://v3n.top/tags/alipay/"/>
    
  </entry>
  
  <entry>
    <title>雪花算法</title>
    <link href="http://v3n.top/2021/03/27/a_id_19/"/>
    <id>http://v3n.top/2021/03/27/a_id_19/</id>
    <published>2021-03-26T16:00:00.000Z</published>
    <updated>2021-06-05T05:43:53.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式系统-SnowFlake-雪花-算法"><a href="#分布式系统-SnowFlake-雪花-算法" class="headerlink" title="分布式系统 SnowFlake(雪花)算法"></a>分布式系统 SnowFlake(雪花)算法</h1><h3 id="引入"><a href="#引入" class="headerlink" title="引入~"></a>引入~</h3><blockquote><p>​        说起用户表以及订单表就必须使用唯一标识，而说起唯一标识大家应该多数都是使用的UUID吧，但是当数据量庞大时，一张表无法承载，就会分出N个表，我们都知道mysql的主键是自增长的、唯一、ID是整型（int），使得查询速度非常快，但是出现分布式系统的话就无法使用mysql自增长ID啦，这个时候就可以使用雪花算法实现唯一标识 ！</p></blockquote><p>为啥它叫雪花算法？ 这是因为我们大家都知道，雪是一团冰晶，在大气中形成，天下不可能有一模一样的雪花，尽管非常的相似，必然它们的形状也是有略不同 </p><p>​    </p><p>首先安装库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install pysnowflake</span><br></pre></td></tr></table></figure><p>安装完成后启动snowflake服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">snowflake_start_server --worker&#x3D;1</span><br></pre></td></tr></table></figure><p>worker指的是节点参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import snowflake.client</span><br><span class="line"></span><br><span class="line">print(snowflake.client.get_guid())</span><br><span class="line">4478873963216244737</span><br></pre></td></tr></table></figure><p>这里看到生成通过二进制转换成19位的十进制数字（id）</p><p>​    这里把它转换成二进制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> bin(4478873963216244737)</span><br><span class="line">&#39;0b11111000101000001010000010001110110011010000000001000000000001&#39;</span><br></pre></td></tr></table></figure><p>然后看到上面所述的是 第一位标识符，后面41位的时间戳，随后10位节点标识码，最后面12位000000000001，在向左数五位这就是存储的唯一标识，转换成10进制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(int(&#39;00001&#39;,2))</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>​        转换结果显示id存储在节点1的数据库中，使用反推逻辑定位到数据存储位置进行查询</p><p>​    </p><p>​        总结：</p><p>​            关于分布式id解决方案就是这样，其实不仅仅只有uuid和snowflake，像其它一些数据库也有独特的分布式        设计方案，使用的话就根据实际应用场景进行使用！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分布式系统-SnowFlake-雪花-算法&quot;&gt;&lt;a href=&quot;#分布式系统-SnowFlake-雪花-算法&quot; class=&quot;headerlink&quot; title=&quot;分布式系统 SnowFlake(雪花)算法&quot;&gt;&lt;/a&gt;分布式系统 SnowFlake(雪花)算法&lt;/</summary>
      
    
    
    
    <category term="个人总结" scheme="http://v3n.top/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="alipay" scheme="http://v3n.top/tags/alipay/"/>
    
  </entry>
  
  <entry>
    <title>关于分页SQL优化问题</title>
    <link href="http://v3n.top/2021/03/04/a_id_18/"/>
    <id>http://v3n.top/2021/03/04/a_id_18/</id>
    <published>2021-03-03T16:00:00.000Z</published>
    <updated>2021-06-05T05:44:15.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="当我们在项目中的订单或者是用户到达海量数据时，无疑是要进行分页的，今天实现下sql查询海量数据时的优化功能。"><a href="#当我们在项目中的订单或者是用户到达海量数据时，无疑是要进行分页的，今天实现下sql查询海量数据时的优化功能。" class="headerlink" title="当我们在项目中的订单或者是用户到达海量数据时，无疑是要进行分页的，今天实现下sql查询海量数据时的优化功能。"></a>当我们在项目中的订单或者是用户到达海量数据时，无疑是要进行分页的，今天实现下sql查询海量数据时的优化功能。</h1><h2 id="实现分页"><a href="#实现分页" class="headerlink" title="实现分页"></a>实现分页</h2><p>首先呢也是通过算法公式计算出起始位置以及终点位置(页头,页尾)</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">info = UserModel.object.all().values() </span></span><br><span class="line"><span class="xml">start = (int(page) - 1) * size  # 起始位置</span></span><br><span class="line"><span class="xml">end = page * size   # 终点位置</span></span><br><span class="line"><span class="xml">data = info[start:end]  # 这里进行切割数据返回给前端</span></span><br></pre></td></tr></table></figure><p>这样其实已经完成了分页的功能，但是这里面是有坑的，什么坑呢，就是说，你每次查询都要从头开始查询，这就导致你查询的数据量非常大，举个例子吧：比如说你有1万的用户信息，每页十条用户信息，那么你会有1000的页数，当你点击第1000页时，mysql的底层查询是从头开始查询，一直查询到你点击的1000页的数据，同理：点击999页、998页都是需要从头开始查询，那这样的话是非常浪费时间的，所以说我们可以给它进行sql优化一下。<br><br></p><p>比如说查询用户,我们直接使用where语句加条件，当id&gt;起始位置时让它直接从起始位置开始查询，这样的话直接是从起始位置开始查询的，这样就节省了很大的空间，我们这边直接使用sql语句进行查询。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id &gt; start limit start,end</span><br></pre></td></tr></table></figure><p><br><br></p><p>使用sql语句查询后，接下来演示一下使用orm语句来查询用户</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">User.objects.filter(id__gte=start).values()[0:10]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;当我们在项目中的订单或者是用户到达海量数据时，无疑是要进行分页的，今天实现下sql查询海量数据时的优化功能。&quot;&gt;&lt;a href=&quot;#当我们在项目中的订单或者是用户到达海量数据时，无疑是要进行分页的，今天实现下sql查询海量数据时的优化功能。&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="个人总结" scheme="http://v3n.top/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="alipay" scheme="http://v3n.top/tags/alipay/"/>
    
  </entry>
  
  <entry>
    <title>异步发请求</title>
    <link href="http://v3n.top/2020/10/23/a_id_17/"/>
    <id>http://v3n.top/2020/10/23/a_id_17/</id>
    <published>2020-10-22T16:00:00.000Z</published>
    <updated>2021-06-05T05:44:20.718Z</updated>
    
    <content type="html"><![CDATA[<h3 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">import httpx</span></span><br><span class="line"><span class="xml">import asyncio</span></span><br><span class="line"><span class="xml">import time</span></span><br><span class="line"></span><br><span class="line"><span class="xml">url = &#x27;http://127.0.0.1:8000/userapp/all/&#x27;  # 记录url</span></span><br><span class="line"></span><br><span class="line"><span class="xml">data = &#123;&#x27;username&#x27;: &#x27;username&#x27;, &#x27;new_of_username&#x27;: &#x27;123&#x27;&#125;  # 参数</span></span><br><span class="line"></span><br><span class="line"><span class="xml">start = time.time()  # 记录开始时间</span></span><br><span class="line"><span class="xml">for i in range(100):</span></span><br><span class="line"><span class="xml">    g = httpx.get(url)  # 展示</span></span><br><span class="line"><span class="xml">    print(g.text)</span></span><br><span class="line"><span class="xml">end = time.time()# 记录结束时间</span></span><br><span class="line"><span class="xml">print(f&quot;同步请求花费时间：&#123;end - start&#125;&quot;)</span></span><br></pre></td></tr></table></figure><h3 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">async def Perform(client):</span></span><br><span class="line"><span class="xml">    r = await client.get(url)</span></span><br><span class="line"><span class="xml">    print(r.text)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="xml">async def main():</span></span><br><span class="line"><span class="xml">    async with httpx.AsyncClient() as client:</span></span><br><span class="line"><span class="xml">        data = []</span></span><br><span class="line"><span class="xml">        for i in range(100):</span></span><br><span class="line"><span class="xml">            info = Perform(client)</span></span><br><span class="line"><span class="xml">            res = asyncio.create_task(info)</span></span><br><span class="line"><span class="xml">            data.append(res)</span></span><br><span class="line"><span class="xml">        await asyncio.gather(*data)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="xml">start_ = time.time()</span></span><br><span class="line"><span class="xml">asyncio.run(main())</span></span><br><span class="line"><span class="xml">end_ = time.time()</span></span><br><span class="line"><span class="xml">print(f&quot;异步请求花费时间：&#123;end_ - start_&#125;&quot;)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;同步请求&quot;&gt;&lt;a href=&quot;#同步请求&quot; class=&quot;headerlink&quot; title=&quot;同步请求&quot;&gt;&lt;/a&gt;同步请求&lt;/h3&gt;&lt;figure class=&quot;highlight django&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;p</summary>
      
    
    
    
    <category term="个人总结" scheme="http://v3n.top/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="alipay" scheme="http://v3n.top/tags/alipay/"/>
    
  </entry>
  
  <entry>
    <title>使用Websocket实现在线人数统计</title>
    <link href="http://v3n.top/2020/10/12/a_id_16/"/>
    <id>http://v3n.top/2020/10/12/a_id_16/</id>
    <published>2020-10-11T16:00:00.000Z</published>
    <updated>2021-06-05T05:44:24.794Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用WebSocket实现在线统计人数"><a href="#使用WebSocket实现在线统计人数" class="headerlink" title="使用WebSocket实现在线统计人数"></a>使用WebSocket实现在线统计人数</h2><h4 id="封装Redis方法-尽量封装类"><a href="#封装Redis方法-尽量封装类" class="headerlink" title="封装Redis方法 (尽量封装类)"></a>封装Redis方法 (尽量封装类)</h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">import redis</span></span><br><span class="line"></span><br><span class="line"><span class="xml">class MrRedis:</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    def __init__(self, **kwargs):</span></span><br><span class="line"><span class="xml">        self.__db = redis.Redis(**kwargs)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    def set(self, key, value):</span></span><br><span class="line"><span class="xml">        self.__db.set(key, value)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    def sety(self, key, value, count):  # set方法 + 过期时间</span></span><br><span class="line"><span class="xml">        self.__db.set(key, value, count)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    def get(self, value):</span></span><br><span class="line"><span class="xml">        return self.__db.get(value)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    def sadd(self, key, value):</span></span><br><span class="line"><span class="xml">        self.__db.sadd(key, value)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    def scard(self, value):</span></span><br><span class="line"><span class="xml">        return self.__db.scard(value)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    def expire(self, key, value):</span></span><br><span class="line"><span class="xml">        self.__db.expire(key, value)</span></span><br></pre></td></tr></table></figure><h4 id="使用websocket建立长连接"><a href="#使用websocket建立长连接" class="headerlink" title="使用websocket建立长连接"></a>使用websocket建立长连接</h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">@accept_websocket</span></span><br><span class="line"><span class="xml">def test_websocket(request, pk):</span></span><br><span class="line"><span class="xml">    while 1:</span></span><br><span class="line"><span class="xml">        if request.is_websocket():</span></span><br><span class="line"><span class="xml">            time.sleep(0.1)  # 间隔时间返回</span></span><br><span class="line"><span class="xml">   request.websocket.send(json.dumps(&#123;&#x27;count&#x27;: MrRedis().scard(&#x27;set_i&#x27;)&#125;))</span></span><br></pre></td></tr></table></figure><h4 id="实现计算人数"><a href="#实现计算人数" class="headerlink" title="实现计算人数"></a>实现计算人数</h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">class MenCount(APIView):</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    def get(self, request):</span></span><br><span class="line"></span><br><span class="line"><span class="xml">        redis_ = MrRedis()</span></span><br><span class="line"></span><br><span class="line"><span class="xml">        if request.META.get(&#x27;HTTP_X_FORWARDED_FOR&#x27;):  # 判断是否为真实IP</span></span><br><span class="line"></span><br><span class="line"><span class="xml">            ip = request.META.get(&quot;HTTP_X_FORWARDED_FOR&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">        else:</span></span><br><span class="line"></span><br><span class="line"><span class="xml">            ip = request.META.get(&quot;REMOTE_ADDR&quot;)  # 代理IP</span></span><br><span class="line"></span><br><span class="line"><span class="xml">        if redis_.scard(&quot;set_i&quot;):  # 返回集合中元素的数量</span></span><br><span class="line"></span><br><span class="line"><span class="xml">            redis_.sadd(&#x27;set_i&#x27;, ip)  # 向集合添加元素 重复忽略</span></span><br><span class="line"></span><br><span class="line"><span class="xml">        else:  # 第一次添加</span></span><br><span class="line"></span><br><span class="line"><span class="xml">            redis_.sadd(&#x27;set_i&#x27;, ip)</span></span><br><span class="line"><span class="xml">            redis_.expire(&#x27;set_i&#x27;, 300)  # 设置5分钟不在消失</span></span><br><span class="line"></span><br><span class="line"><span class="xml">        return Response(&#123;&#x27;count&#x27;: redis_.scard(&#x27;set_i&#x27;)&#125;)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用WebSocket实现在线统计人数&quot;&gt;&lt;a href=&quot;#使用WebSocket实现在线统计人数&quot; class=&quot;headerlink&quot; title=&quot;使用WebSocket实现在线统计人数&quot;&gt;&lt;/a&gt;使用WebSocket实现在线统计人数&lt;/h2&gt;&lt;h4 i</summary>
      
    
    
    
    <category term="个人总结" scheme="http://v3n.top/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="alipay" scheme="http://v3n.top/tags/alipay/"/>
    
  </entry>
  
  <entry>
    <title>Webshell</title>
    <link href="http://v3n.top/2020/09/11/a_id_15/"/>
    <id>http://v3n.top/2020/09/11/a_id_15/</id>
    <published>2020-09-10T16:00:00.000Z</published>
    <updated>2021-06-05T05:44:29.353Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是webshell"><a href="#一、什么是webshell" class="headerlink" title="一、什么是webshell"></a>一、什么是webshell</h2><ul><li><p>webshell简介</p><p>webshell，顾名思义：web指的是web服务器上，而shell，是用脚本语言编写的脚本程序，webshell就是web的一个管理工具，可以对web服务器进行操作的权限，也叫webadmin。webshell一般是被网站管理员用于网站管理、服务器管理等等一些用途，但是由于webshell的功能比较强大，可以上传下载文件，查看数据库，甚至可以调用一些服务器上系统的相关命令，通常被黑客利用，黑客通过一些上传方式，将自己编写的webshell上传到web服务器的页面的目录下，然后通过页面访问的形式进行入侵，或者通过插入一句话连接本地的一些相关工具直接对服务器进行入侵操作。  </p></li><li><p>webshell分类</p><p>webshell根据脚本可以分为PHP脚本木马，ASP脚本木马，也有基于.NET的脚本木马和JSP脚本木马。在国外，还有用python脚本语言写的动态网页，当然也有与之相关的webshell。<br>根据功能也分为大马与小马，小马通常指的一句话木马，例如：&lt;%eval request(“pass”)%&gt;通常把这句话写入一个文档里面，然后文件名改成xx.asp。然后传到服务器上面。这里eval方法将request(“pass”)转换成代码执行，request函数的作用是应用外部文件。这相当于一句话木马的客户端配置。  </p></li></ul><h2 id="二、实践"><a href="#二、实践" class="headerlink" title="二、实践"></a>二、实践</h2><p>使用webshell在浏览器实现黑窗口</p><h4 id="2-1-首先下载"><a href="#2-1-首先下载" class="headerlink" title="2.1 首先下载"></a>2.1 首先下载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install xterm@3.1.0 –save</span><br></pre></td></tr></table></figure><h4 id="2-2-在Vue页面中导入包"><a href="#2-2-在Vue页面中导入包" class="headerlink" title="2.2 在Vue页面中导入包"></a>2.2 在Vue页面中导入包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import * as attach from &quot;xterm&#x2F;lib&#x2F;addons&#x2F;attach&#x2F;attach&quot;; &#x2F;&#x2F; 安装插件可以使用attach添加</span><br><span class="line">import * as fit from &quot;xterm&#x2F;lib&#x2F;addons&#x2F;fit&#x2F;fit&quot;; &#x2F;&#x2F;  黑窗口可以自适度屏幕大小</span><br><span class="line">import &#123; coursedetail &#125; from &quot;@&#x2F;http&#x2F;api&quot;; &#x2F;&#x2F;  导入请求</span><br><span class="line"></span><br><span class="line">Terminal.applyAddon(attach); &#x2F;&#x2F; 添加插件</span><br><span class="line">Terminal.applyAddon(fit); &#x2F;&#x2F; 插件</span><br></pre></td></tr></table></figure><h4 id="2-3-初始化div对象"><a href="#2-3-初始化div对象" class="headerlink" title="2.3 初始化div对象"></a>2.3 初始化div对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">    &#x2F;&#x2F;  获取div标签</span><br><span class="line">    let terminalLcontainer &#x3D; document.getElementById(&quot;terminal&quot;);</span><br><span class="line">    &#x2F;&#x2F;  初始化对象</span><br><span class="line">    this.term &#x3D; new Terminal(this.termail);</span><br><span class="line">    &#x2F;&#x2F;  打开对象</span><br><span class="line">    this.term.open(terminalLcontainer); </span><br><span class="line"> </span><br><span class="line">    this.terminalSocket &#x3D; new WebSocket(&quot;ws:&#x2F;&#x2F;127.0.0.1:8000&#x2F;course&#x2F;webssh&#x2F;&quot;);</span><br><span class="line">    this.terminalSocket.onopen &#x3D; function() &#123;</span><br><span class="line">      &#x2F;&#x2F; 连接成功触发该方法</span><br><span class="line">      this.term_status &#x3D; true</span><br><span class="line">      console.log(&quot;websocket is Connected...&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    this.terminalSocket.onclose &#x3D; function() &#123;</span><br><span class="line">      &#x2F;&#x2F; 连接关闭适触发的方法</span><br><span class="line">      console.log(&quot;websocket is Closed...&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    this.terminalSocket.onerror &#x3D; function() &#123;</span><br><span class="line">      &#x2F;&#x2F; 连接出错触发的方法</span><br><span class="line">      console.log(&quot;damn Websocket is broken!&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    this.term.attach(this.terminalSocket)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-下载dwebsocket"><a href="#2-4-下载dwebsocket" class="headerlink" title="2.4 下载dwebsocket"></a>2.4 下载dwebsocket</h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">pip install dwebsocket</span></span><br></pre></td></tr></table></figure><p>在settings中配置<br><img src="/.top//4.1.jpg"></p><h4 id="2-5-初始化一个ssh对象"><a href="#2-5-初始化一个ssh对象" class="headerlink" title="2.5 初始化一个ssh对象"></a>2.5 初始化一个ssh对象</h4><p><img src="/.top//4.2.jpg"></p><h4 id="2-6-建立ssh连接通道"><a href="#2-6-建立ssh连接通道" class="headerlink" title="2.6 建立ssh连接通道"></a>2.6 建立ssh连接通道</h4><p><img src="/.top//4.4.jpg"></p><h4 id="2-7-启动"><a href="#2-7-启动" class="headerlink" title="2.7 启动"></a>2.7 启动</h4><p><img src="/.top//4.3.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、什么是webshell&quot;&gt;&lt;a href=&quot;#一、什么是webshell&quot; class=&quot;headerlink&quot; title=&quot;一、什么是webshell&quot;&gt;&lt;/a&gt;一、什么是webshell&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;webshell简介&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="个人总结" scheme="http://v3n.top/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="alipay" scheme="http://v3n.top/tags/alipay/"/>
    
  </entry>
  
  <entry>
    <title>面向对象封装Redis</title>
    <link href="http://v3n.top/2020/08/20/a_id_14/"/>
    <id>http://v3n.top/2020/08/20/a_id_14/</id>
    <published>2020-08-19T16:00:00.000Z</published>
    <updated>2021-06-05T05:44:39.980Z</updated>
    
    <content type="html"><![CDATA[<h3 id="封装Redis"><a href="#封装Redis" class="headerlink" title="封装Redis"></a>封装Redis</h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">import redis</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="xml">class MrRedis:</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    def __init__(self, **kwargs):</span></span><br><span class="line"><span class="xml">        self.__db = redis.Redis(**kwargs, decode_responses=True)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    def set(self, key, value):</span></span><br><span class="line"><span class="xml">        self.__db.set(key, value)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    def sety(self, key, value, count):  # set方法 + 过期时间</span></span><br><span class="line"><span class="xml">        self.__db.set(key, value, count)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    def get(self, value):</span></span><br><span class="line"><span class="xml">        return self.__db.get(value)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    def sadd(self, key, value):</span></span><br><span class="line"><span class="xml">        self.__db.sadd(key, value)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    def scard(self, value):</span></span><br><span class="line"><span class="xml">        return self.__db.scard(value)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    def expire(self, key, value):</span></span><br><span class="line"><span class="xml">        self.__db.expire(key, value)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;封装Redis&quot;&gt;&lt;a href=&quot;#封装Redis&quot; class=&quot;headerlink&quot; title=&quot;封装Redis&quot;&gt;&lt;/a&gt;封装Redis&lt;/h3&gt;&lt;figure class=&quot;highlight django&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class</summary>
      
    
    
    
    <category term="个人总结" scheme="http://v3n.top/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="alipay" scheme="http://v3n.top/tags/alipay/"/>
    
  </entry>
  
  <entry>
    <title>Mysql联合索引</title>
    <link href="http://v3n.top/2020/08/13/a_id_13/"/>
    <id>http://v3n.top/2020/08/13/a_id_13/</id>
    <published>2020-08-12T16:00:00.000Z</published>
    <updated>2021-06-05T05:42:02.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于mysql联合索引的最左前缀原则以及b-tree"><a href="#关于mysql联合索引的最左前缀原则以及b-tree" class="headerlink" title="关于mysql联合索引的最左前缀原则以及b+tree"></a>关于mysql联合索引的最左前缀原则以及b+tree</h1><p style="font-size:23px">查询条件要符合最左原则才能使用到索引</p><br><p style="font-size:23px">首先介绍下联合索引</p><br>      最重要的一点是覆盖索引，非主键索引会先查到主键索引的值再从主键索引上拿到想要的值，会多一次索引下推，覆盖索引可以直接在非主键索引上拿到对应的值，减少一次查询，<br><br><p style="font-size:23px">最左查询 </p><pre><code>    也就是说先查询最左边的，在检索数据时从联合索引的最左边开始匹配，类似于给 index （name,age,gender）三个字段加上联合索引 等于加上了（name,age） （name,gender） （name,age,gender） 这三种查询优化组合 </code></pre><br><p style="font-size:23px">举个例子 </p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE pay(</span><br><span class="line">    id INT,</span><br><span class="line">    NAME  </span><br><span class="line">    index (name,age,gender)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></code></pre><br><p style="font-size:23px">这个时候可以使用EXPLAIN计划任务来查询是否命中索引,</p><p style="color:red">possible_keys</p>    根据这个字段可以解读是否命中索引, <p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM pay WHERE  NAME &#x3D; &#39;王杰&#39; AND age &#x3D; 24 AND gender &#x3D; &#39;男&#39;;</span><br><span class="line">目前这条sql语句已经出现了index索引</span><br><span class="line">idselect_typetablepartitionstypepossible_keyskeykey_lenrefrowsfilteredExtra</span><br><span class="line">1SIMPLEpay\Nref        indexindex        325const,const,const1100.00Using index</span><br></pre></td></tr></table></figure><br><p style="font-size:23px">然后我们再只根据年龄做查询看一下是否能够命中索引，很显然possible_keys    为NULL，说明并没有命中索引因为它不符合最左原则，因为它没有命中（name，age） （name，gender） （name，age，gender）这种组合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM pay WHERE  age &#x3D; 24;</span><br><span class="line">目前这条sql语句已经出现了index索引</span><br><span class="line">idselect_typetablepartitionstypepossible_keyskeykey_lenrefrowsfilteredExtra</span><br><span class="line">1SIMPLEpay\Nref        index(NULL))        325const,const,const1100.00Using index</span><br></pre></td></tr></table></figure><br><p style="font-size:23px">另外使用执行计划一定要看结果，只有possible_keys有值的情况下才是命中索引</p><br><p>还有就是where条件的顺序是否会影响索引的命中，就是本来(name,age)的组合，故意写where语句时写成(age,name)，答案是没有影响，只要遵循了索引的最左原则就可以</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于mysql联合索引的最左前缀原则以及b-tree&quot;&gt;&lt;a href=&quot;#关于mysql联合索引的最左前缀原则以及b-tree&quot; class=&quot;headerlink&quot; title=&quot;关于mysql联合索引的最左前缀原则以及b+tree&quot;&gt;&lt;/a&gt;关于mysql联</summary>
      
    
    
    
    <category term="个人总结" scheme="http://v3n.top/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="alipay" scheme="http://v3n.top/tags/alipay/"/>
    
  </entry>
  
  <entry>
    <title>无限极分类</title>
    <link href="http://v3n.top/2020/07/01/a_id_12/"/>
    <id>http://v3n.top/2020/07/01/a_id_12/</id>
    <published>2020-06-30T16:00:00.000Z</published>
    <updated>2021-06-05T05:41:47.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>无限极分类简单点说就是一个类可以分成多个子类，然后一个子类又可以分另外多个子类这样无限分下去，就好象windows可以新建一个文件夹，然后在这个文件夹里又可以建一些个文件夹，在文件夹底下还可以建一些文件夹一样</p><h2 id="实践操作"><a href="#实践操作" class="headerlink" title="实践操作"></a>实践操作</h2><h4 id="1-首先创建模型表"><a href="#1-首先创建模型表" class="headerlink" title="1. 首先创建模型表"></a>1. 首先创建模型表</h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">class CaiModel(models.Model):</span></span><br><span class="line"><span class="xml">    name = models.CharField(max_length=200)</span></span><br><span class="line"><span class="xml">    par = models.ForeignKey(&#x27;self&#x27;, on_delete=models.SET_NULL, null=True, blank=True)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    def __str__(self):</span></span><br><span class="line"><span class="xml">        return self.name</span></span><br></pre></td></tr></table></figure><h4 id="2-序列化器"><a href="#2-序列化器" class="headerlink" title="2. 序列化器"></a>2. 序列化器</h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">from rest_framework import serializers</span></span><br><span class="line"><span class="xml">from app1.models import CaiModel</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="xml">class CaiSerializers(serializers.ModelSerializer):</span></span><br><span class="line"><span class="xml">    class Meta:</span></span><br><span class="line"><span class="xml">        model = CaiModel</span></span><br><span class="line"><span class="xml">        fields = &#x27;__all__&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="3-写一个递归的方法"><a href="#3-写一个递归的方法" class="headerlink" title="3. 写一个递归的方法"></a>3. 写一个递归的方法</h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">def xTree(datas):</span></span><br><span class="line"><span class="xml">    lists = []  # 定义空列表</span></span><br><span class="line"><span class="xml">    tree = &#123;&#125;  # 定义空字典</span></span><br><span class="line"><span class="xml">    for i in datas:</span></span><br><span class="line"><span class="xml">        item = i</span></span><br><span class="line"><span class="xml">        tree[item[&#x27;id&#x27;]] = item</span></span><br><span class="line"></span><br><span class="line"><span class="xml">    for i in datas:</span></span><br><span class="line"><span class="xml">        obj = i</span></span><br><span class="line"><span class="xml">        if not obj[&#x27;par&#x27;]:</span></span><br><span class="line"><span class="xml">            root = tree[obj[&#x27;id&#x27;]]</span></span><br><span class="line"><span class="xml">            lists.append(root)</span></span><br><span class="line"><span class="xml">        else:</span></span><br><span class="line"><span class="xml">            parent_id = obj[&#x27;par&#x27;]</span></span><br><span class="line"><span class="xml">            if &#x27;childlist&#x27; not in tree[parent_id]:</span></span><br><span class="line"><span class="xml">                tree[parent_id][&#x27;childlist&#x27;] = []</span></span><br><span class="line"><span class="xml">            tree[parent_id][&#x27;childlist&#x27;].append(tree[obj[&#x27;id&#x27;]])</span></span><br><span class="line"><span class="xml">    return lists</span></span><br></pre></td></tr></table></figure><h4 id="4-写一个视图函数-接收数据"><a href="#4-写一个视图函数-接收数据" class="headerlink" title="4. 写一个视图函数, 接收数据"></a>4. 写一个视图函数, 接收数据</h4><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">class MyTree(APIView):</span></span><br><span class="line"><span class="xml">    def get(self, request):</span></span><br><span class="line"><span class="xml">        &quot;&quot;&quot;</span></span><br><span class="line"><span class="xml">        查找</span></span><br><span class="line"><span class="xml">        :param request:</span></span><br><span class="line"><span class="xml">        :return:</span></span><br><span class="line"><span class="xml">        &quot;&quot;&quot;</span></span><br><span class="line"><span class="xml">        cai = CaiModel.objects.all()</span></span><br><span class="line"><span class="xml">        ser = CaiSerializers(cai, many=True)</span></span><br><span class="line"><span class="xml">        data = xTree(ser.data)</span></span><br><span class="line"><span class="xml">        return Response(data)</span></span><br></pre></td></tr></table></figure><h4 id="5-实现"><a href="#5-实现" class="headerlink" title="5. 实现"></a>5. 实现</h4><p><img src="/.top//5.1.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;无限极分类简单点说就是一个类可以分成多个子类，然后一个子类又可以分另外多个子类这样无限分下去，就好象windows可以新建一个文件夹，然后在</summary>
      
    
    
    
    <category term="个人总结" scheme="http://v3n.top/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="alipay" scheme="http://v3n.top/tags/alipay/"/>
    
  </entry>
  
  <entry>
    <title>Git分支管理</title>
    <link href="http://v3n.top/2020/06/27/a_id_11/"/>
    <id>http://v3n.top/2020/06/27/a_id_11/</id>
    <published>2020-06-26T16:00:00.000Z</published>
    <updated>2021-06-05T05:41:09.982Z</updated>
    
    <content type="html"><![CDATA[<h4 id="为什么使用git分支呢"><a href="#为什么使用git分支呢" class="headerlink" title="为什么使用git分支呢?"></a>为什么使用git分支呢?</h4><ul><li><p>一般情况，master主分支不做开发，master主分支只做<a href="%E9%A1%B9%E7%9B%AE%E5%AE%8C%E6%88%90%E6%97%A0%E5%BC%82%E5%B8%B8%EF%BC%8C%E5%BC%80%E5%A7%8B%E9%83%A8%E7%BD%B2%E7%9A%84%E5%8F%AB%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83">生产环境</a>。</p></li><li><p>开发一般在次分支，因为我们在开发过程中，代码避免出现Bug或者修改部分，这些问题在次分支解决，解决Bug完成后，没有任何问题，合并到master主分支</p></li><li><p>总之：master主分支只做生产环境，次分支是为了开发建立的，最后次分支没有任何异常，合并到主分支master。</p></li></ul><h4 id="分支命令"><a href="#分支命令" class="headerlink" title="分支命令"></a>分支命令</h4><p>· * 代表你当前所在的分支</p><p>查看所有分支：git    branch  -a</p><p>查看云端分支：git    branch   -r</p><p>拉取分支和代码：git pull  </p><p>切换分支: git checkout 分支名</p><ul><li><p>合并代码</p><ul><li><p>首先进入master</p><p>合并: git merge 分支名</p><p>合并后:  git push  当前分支</p><p>素质三连</p></li></ul></li></ul><pre><code>git merge特点: - 只处理一次冲突- 会记录合并的历史记录, 合并的commit 按照提交时间排列展示- 所有的过程信息更多，可能会提高之后查找问题的难度</code></pre><ul><li><p>mebase 合并特点</p><ul><li>没有多余的合并历史的记录，且合并后的 <code>commit</code> 顺序不一定按照 <code>commit</code> 的提交时间排列</li><li>更清爽一些，<code>master</code> 分支上每个 <code>commit</code> 点都是相对独立完整的功能单元</li></ul></li></ul><h4 id="合并代码总结"><a href="#合并代码总结" class="headerlink" title="合并代码总结:"></a>合并代码总结:</h4><p>  当需要保留详细的合并信息的时候建议使用git merge，特别是需要将分支合并进入master分支时；当发现自己修改某个功能时，频繁进行了git commit提交时，发现其实过多的提交信息没有必要时，可以尝试git rebase。</p><p>​       </p><h4 id="代码回退"><a href="#代码回退" class="headerlink" title="代码回退"></a>代码回退</h4><p>​    查看日志:  git log</p><p>​    回退到指定版本:  git reset  –hard  日制id</p><p>​    推送:  git push origin HEAD –force</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;为什么使用git分支呢&quot;&gt;&lt;a href=&quot;#为什么使用git分支呢&quot; class=&quot;headerlink&quot; title=&quot;为什么使用git分支呢?&quot;&gt;&lt;/a&gt;为什么使用git分支呢?&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一般情况，master主分支不做开发，mast</summary>
      
    
    
    
    <category term="个人总结" scheme="http://v3n.top/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="alipay" scheme="http://v3n.top/tags/alipay/"/>
    
  </entry>
  
  <entry>
    <title>set，zset底层实现</title>
    <link href="http://v3n.top/2020/05/18/a_id_10/"/>
    <id>http://v3n.top/2020/05/18/a_id_10/</id>
    <published>2020-05-17T16:00:00.000Z</published>
    <updated>2021-06-05T05:40:59.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis五大数据类型-Set与Zset"><a href="#Redis五大数据类型-Set与Zset" class="headerlink" title="Redis五大数据类型 Set与Zset"></a>Redis五大数据类型 Set与Zset</h1><p style="font-size:20px">Redis的set相信大家都是使用过的，set的去重也是非常的好用，相信大多数人都会使用.</p><br><br><p style="font-size:15px">比如说实现在线人数统计，我们只需要把ip扔进set里，重复的会自动去掉，但是却很少有人知道他的底层逻辑是怎么实现的呢?</p><br><br><p style="font-size:15px"> 首先呢必须有一个新的容器，用于存储新的数据，然后的话将自己的容器进行遍历判断与新的容器中数据作对比，如果存在，直接丢弃，不存在写入新的容器.<br><br></p><p style="font-size:15px">我这边举个生活中的例子，比如说买金鱼，你想要不重复的金鱼，你是不是得拿一个新盆子捞鱼，捞出来之后与容器中对比，相同的鱼扔掉，不一样放进去</p><br><p>这就是set去重逻辑底层实现!</p><br><h1 id="Zset有序集合"><a href="#Zset有序集合" class="headerlink" title="Zset有序集合"></a>Zset有序集合</h1><p style="font-size:15px">这里说一下这个有序集合这块的底层实现，有序集合大家也不陌生，因为我自己有时候也玩游戏嘛，就是一个无意间发现它这个游戏的排行榜功能，经过自己研究呢，也是完成了，我呢是使用的Redis的有序集合实现的这个排行榜功能，</p><br><h5 id="描述"><a href="#描述" class="headerlink" title="描述:"></a>描述:</h5><p style="font-size:15px">  　　我就使用用户积分做这个排行榜了，做之前也是想到了排行榜这个东西令人头疼的不是查数据，而是说排行榜随时有可能插入一个用户，通过这个可以想到数组，但是它是连续的，数据都是挨着的，线性结构，查询利用折半查找也是非常方便，非常快，但是如果向数组插数据是非常的困难的，比如说一百万的数据，我想插入中间，前面五十万得往前腾地方，后面也是往后腾地方，举个例子比如说电影院里，假如一排有一个人做错位置，那这一排的人都要动，这就是数组，插入和修改的效率及其低，反之查找的速度很快的，利用二分查找.</p><br><br><h5 id="Zset底层实现"><a href="#Zset底层实现" class="headerlink" title="Zset底层实现:"></a>Zset底层实现:</h5><p style="font-size:15px">　　因此当时我也是使用的链表，因为链表是非线性结构的，永远都是有一根指针指向地址，不需要来回腾位置，链表的好处就是随时插入数据，插入方便，当然的话链表的查询也是非常慢，链表的劣势就是说我需要遍历所有的节点来查找，有100万就要遍历一百万次，因为只有线性结构才可以使用折半查找， 解决方案的话也就是使用跳表的使用.  <br><pre><code>什么是跳表呢?(以空间换时间)跳表就是跳跃表，使用位运算对奇数抽出比如说:  　　 第一次跳 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7 　　 第二次跳 1-&gt;3-&gt;5-&gt;7  第二次这里使用位运算抽取出奇数的数查取  　　 第三次跳 1-&gt;7     </code></pre></p><br><h3 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h3><ul><li><p>set集合的底层逻辑已经在上面写好了  </p></li><li><p>排行榜功能由Redis-&gt;Zadd(有序集合)-&gt;链表-&gt;跳表</p></li><li><p> 链表的内存地址是随机的，由指针指向，好处就是，插入和修改方便，不考虑位置关系 </p></li><li><p>因为链表是非线性结构，无法使用折半查找， 查询慢</p></li></ul><br>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis五大数据类型-Set与Zset&quot;&gt;&lt;a href=&quot;#Redis五大数据类型-Set与Zset&quot; class=&quot;headerlink&quot; title=&quot;Redis五大数据类型 Set与Zset&quot;&gt;&lt;/a&gt;Redis五大数据类型 Set与Zset&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="个人总结" scheme="http://v3n.top/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="alipay" scheme="http://v3n.top/tags/alipay/"/>
    
  </entry>
  
  <entry>
    <title>唯一索引与Docker基操</title>
    <link href="http://v3n.top/2020/05/10/a_id_9/"/>
    <id>http://v3n.top/2020/05/10/a_id_9/</id>
    <published>2020-05-09T16:00:00.000Z</published>
    <updated>2021-06-05T05:40:45.572Z</updated>
    
    <content type="html"><![CDATA[<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><ul><li><p>唯一索引干嘛用的</p><p>应用场景：用户注册的用户名，手机号，邮箱，身份证信息，学号等场景</p></li><li><p>为什么使用唯一索引</p><p>唯一索引就是该字段数据不能重复，可以有一个为空，只要不重复就可以，与主键不同的是，一张表中只能有一个主键，主键不能为空，使用唯一索引的好处就是可以避免数据重复出现，也是提高了访问速度.</p></li></ul><h3 id="Docker操作基本命令"><a href="#Docker操作基本命令" class="headerlink" title="Docker操作基本命令"></a>Docker操作基本命令</h3><ul><li><p>启动docker服务</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure></li><li><p>停止docker服务</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure></li><li><p>重启docker服务</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure></li><li><p>拉取镜像</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 镜像名</span><br></pre></td></tr></table></figure></li><li><p>查看镜像 -a:本地所有镜像  -q: 显示镜像id</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images -a </span><br></pre></td></tr></table></figure></li><li><p>创建容器 </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-p指定端口映射 -P随机端口映射</span><br><span class="line">docker run -d -p 映射端口:端口号 镜像id</span><br></pre></td></tr></table></figure></li><li><p>启动容器</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器id</span><br></pre></td></tr></table></figure></li><li><p>关闭容器</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器id</span><br></pre></td></tr></table></figure></li><li><p>重启容器</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart 容器id</span><br></pre></td></tr></table></figure></li><li><p>查看正在启动的容器</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure></li><li><p>查看所有的容器 </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure></li><li><p>删除镜像</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 镜像id</span><br></pre></td></tr></table></figure></li><li><p>删除容器 参数: -f 强删</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 容器id</span><br></pre></td></tr></table></figure></li><li><p>查看容器日志 </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-f : 查看实时日志</span><br><span class="line">-t : 查看日志产生的日期</span><br><span class="line">docker logs 容器id</span><br></pre></td></tr></table></figure></li></ul><p>​<br>​    </p><p>​    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;唯一索引&quot;&gt;&lt;a href=&quot;#唯一索引&quot; class=&quot;headerlink&quot; title=&quot;唯一索引&quot;&gt;&lt;/a&gt;唯一索引&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;唯一索引干嘛用的&lt;/p&gt;
&lt;p&gt;应用场景：用户注册的用户名，手机号，邮箱，身份证信息，学号等场景&lt;/p&gt;
</summary>
      
    
    
    
    <category term="个人总结" scheme="http://v3n.top/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="alipay" scheme="http://v3n.top/tags/alipay/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL</title>
    <link href="http://v3n.top/2020/04/24/a_id_8/"/>
    <id>http://v3n.top/2020/04/24/a_id_8/</id>
    <published>2020-04-23T16:00:00.000Z</published>
    <updated>2021-06-05T05:40:20.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前几天在leetcode上做题的时候，无意发现一道这样的需求题-如何使用一条sql语句查询出所有部门的平均工资以及每个部门个人工资的对比。"><a href="#前几天在leetcode上做题的时候，无意发现一道这样的需求题-如何使用一条sql语句查询出所有部门的平均工资以及每个部门个人工资的对比。" class="headerlink" title="前几天在leetcode上做题的时候，无意发现一道这样的需求题,如何使用一条sql语句查询出所有部门的平均工资以及每个部门个人工资的对比。"></a>前几天在leetcode上做题的时候，无意发现一道这样的需求题,如何使用一条sql语句查询出所有部门的平均工资以及每个部门个人工资的对比。</h1><p><br><br></p><p>首先我们先创建下部门表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE department(</span><br><span class="line">    id int, </span><br><span class="line">    deptname varchar(100),</span><br><span class="line">    salary int</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>然后的话我们直接给它添加测试数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO department</span><br><span class="line">values(1,&#39;技术部&#39;,13000),</span><br><span class="line">(2,&#39;技术部&#39;,16000),</span><br><span class="line">(3,&#39;行政&#39;,8000),</span><br><span class="line">(4,&#39;行政&#39;,5000)</span><br></pre></td></tr></table></figure><p><br><br></p><p>这里是展示数据展示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id | depname | userid | salary</span><br><span class="line">----+---------+--------+--------</span><br><span class="line"> 1 | 技术部  |      1 |  13000</span><br><span class="line"> 2 | 技术部  |      2 |  16000</span><br><span class="line"> 3 | 行政    |      8 |   8000</span><br><span class="line"> 4 | 行政    |      9 |   5000</span><br></pre></td></tr></table></figure><p><br><br></p><p>那么怎么实现上面的需求呢？ sql语句可以这样写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">select department.id,department.depname,department.salary,newtable.avsa</span><br><span class="line"></span><br><span class="line">-&gt; from department</span><br><span class="line"></span><br><span class="line">-&gt; inner join</span><br><span class="line"></span><br><span class="line">-&gt; (</span><br><span class="line"></span><br><span class="line">-&gt; select depname,avg(salary) as avsa from department group by depname</span><br><span class="line"></span><br><span class="line">-&gt; )</span><br><span class="line"></span><br><span class="line">-&gt; as newtable</span><br><span class="line"></span><br><span class="line">-&gt; on department.depname &#x3D; newtable.depname;</span><br></pre></td></tr></table></figure><p><br><br></p><p>这样的就查询出来了，该题概括mysql知识点也是非常全面，像聚合索引、分组、子查询等都涉及到了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+----+-----------+--------+------------+</span><br><span class="line">| id | depname   | salary | avsa       |</span><br><span class="line">+----+-----------+--------+------------+</span><br><span class="line">|  1 | 技术部    |  15000 | 15500.0000 |</span><br><span class="line">|  2 | 技术部    |  16000 | 15500.0000 |</span><br><span class="line">|  3 | 行政      |   8000 |  6500.0000 |</span><br><span class="line">|  4 | 行政      |   5000 |  6500.0000 |</span><br><span class="line">+----+-----------+--------+------------+</span><br></pre></td></tr></table></figure><p><br><br><br><br>小结：这样的话确实是把我们想要的答案查询出来，但是的sql语句未必显得有点麻烦，下面介绍另一款数据库。</p><p><br><br></p><h1 id="PostgreSQL是一种数据库管理系统，支持大部分的SQL标准并且提供了很多其他现代特性，如复杂查询、外键、触发器、视图、事务完整性、多版本并发控制等，并且这款数据库也是免费使用的"><a href="#PostgreSQL是一种数据库管理系统，支持大部分的SQL标准并且提供了很多其他现代特性，如复杂查询、外键、触发器、视图、事务完整性、多版本并发控制等，并且这款数据库也是免费使用的" class="headerlink" title="PostgreSQL是一种数据库管理系统，支持大部分的SQL标准并且提供了很多其他现代特性，如复杂查询、外键、触发器、视图、事务完整性、多版本并发控制等，并且这款数据库也是免费使用的"></a>PostgreSQL是一种数据库管理系统，支持大部分的SQL标准并且提供了很多其他现代特性，如复杂查询、外键、触发器、视图、事务完整性、多版本并发控制等，并且这款数据库也是免费使用的</h1><p><img src="/.top//04/24/a_id_8/post.png"></p><p style="font-size:23px">我们直接在Docker上安装<b>PostgreSQL</b>数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull postgres:11.1</span><br></pre></td></tr></table></figure><br><p style="font-size:23px">拉取成功后可以查看下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><br><p style="font-size:23px">然后的话我们就可以启动容器啦</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name dev-postgres -e POSTGRES_PASSWORD&#x3D;root -p 5432:5432 postgres:11.1</span><br></pre></td></tr></table></figure><br><p style="font-size:23px">我们直接exec进入容器内部的命令行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it dev-postgres bash psql -h localhost -U postgres</span><br></pre></td></tr></table></figure><br><p style="font-size:23px">在命令行输入 \l 查看数据库列表</p><p><img src="/.top//04/24/a_id_8/1.png"></p><br><p style="font-size:23px"> 使用数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\c mytest</span><br></pre></td></tr></table></figure><br><p style="font-size:23px"> 建立表</p><p><img src="/.top//04/24/a_id_8/2.png"></p><br><p style="font-size:23px"> \d查看表</p><br><p style="font-size:23px">over子句的应用，假设我们有一个员工薪资的表（部门、员工id，工资）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id | depname | userid | salary</span><br><span class="line"> ----+---------+--------+--------</span><br><span class="line"> 1 | 技术部  |      1 |  15000</span><br><span class="line"> 2 | 技术部  |      2 |  20000</span><br><span class="line"> 3 | 行政    |      8 |   4000</span><br><span class="line"> 4 | 行政    |      9 |   8000</span><br></pre></td></tr></table></figure><br><p style="font-size:23px">还是根据我们上面的需求题,现在我想将每一个员工的工资与他所在部门的平均工资做个比较，怎么做？来看下如何实现,这也是leetcode原题,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT depname,userid,salary,avg(salary) OVER (PARTITION BY depname) FROM AG;</span><br></pre></td></tr></table></figure>    <p style="font-size:23px">        查询结果：<pre><code>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> depname | userid | salary |          avg</span><br><span class="line"> ---------+--------+--------+-----------------------</span><br><span class="line">技术部  |      1 |  15000 |    17500.000000000000</span><br><span class="line">技术部  |      2 |  20000 |    17500.000000000000</span><br><span class="line">行政    |      8 |   4000 | 6000.0000000000000000</span><br><span class="line">行政    |      9 |   8000 | 6000.0000000000000000</span><br></pre></td></tr></table></figure>&lt;/p&gt;</code></pre></p><p style="font-size:23px">        使用容器启动数据库会有个问题，就是每次容器停止，数据就会丢失，所有我们可以用docker的挂载命令将数据存在宿主机中，这样就可以持久化保存数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name dev-postgres -e POSTGRES_PASSWORD&#x3D;root -e PGDATA&#x3D;&#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data&#x2F;pgdata</span><br><span class="line">-v &#x2F;custom&#x2F;mount:&#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data  -p 6432:5432 postgres:11.1</span><br></pre></td></tr></table></figure><br><br><p style="font-size:23px">        结论：自从Mysql被Oracle收购的时候，它已经不是开源的最佳选择，所以说可以适当的走向PostgreSQL！</p><p><br><br><br><br><br><br><br><br><br><br><br><br><br></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前几天在leetcode上做题的时候，无意发现一道这样的需求题-如何使用一条sql语句查询出所有部门的平均工资以及每个部门个人工资的对比。&quot;&gt;&lt;a href=&quot;#前几天在leetcode上做题的时候，无意发现一道这样的需求题-如何使用一条sql语句查询出所有部门的</summary>
      
    
    
    
    <category term="个人总结" scheme="http://v3n.top/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="alipay" scheme="http://v3n.top/tags/alipay/"/>
    
  </entry>
  
</feed>
